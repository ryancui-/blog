[{"title":"Chrome 插件开发小结","date":"2018-10-18T03:32:42.000Z","path":"2018/10/18/chrome-extension-dev/","text":"最近都在做 Chrome 插件的开发，虽然一开始整个插件的框不是我搭起来的，但在过程中遇到的一些问题和解决方法，也值得总结一下。 使用 Vue.js 开发 Chrome 插件这个插件在打开的时候会弹出一个操作页面与用户进行交互，这个操作页面可以用 Vue.js 来开发，本质上与开发一个普通的 Vue Web 应用差不多。 那么怎么把这个页面放进需要展示的 Tab 中呢，我们使用了 iframe： const frame_id = this.frame_idthis.frame = $(`#$&#123;frame_id&#125;`)if (!this.frame.length) &#123; // 未渲染 let indexURL = chrome.runtime.getURL('index.html') this.frame = $(`&lt;iframe src=\"$&#123;indexURL&#125;\" id=\"$&#123;frame_id&#125;\"&gt;&lt;/iframe&gt;`) $(document.body).append(this.frame)&#125; 打包好 Vue 的应用后，通过 chrome.runtime.getURL 获取 index.html 的路径，往页面添加一个 iframe 显示。 需要注意的是，这个 iframe 的构造和插入是在 Chrome 插件的 content script 中，其实本质上与插件自带的 popup html 选项是一致的，iframe 中加载的 js 也属于插件的 content script. 其他页面的开发方式、Vuex 的使用等与平常使用基本相同。 三个区域 Background/Content/Frame 的通信 页面架构 采用插入 iframe 的方式，整个应用被划分成了三块： Background：常驻在浏览器的 JavaScript 脚本 Content：打开的网页本来的 JavaScript 脚本（环境） Frame：从插件 content script 中调用 js 插入的一个 iframe 的 JavaScript 脚本（环境） 虽然 Content 与 Frame 两部分在 Chrome 插件上均属于 content script 的范畴，但由于 Chrome 插件的限制，这两块的 JavaScript 执行环境并不一致，因此这两部分也需要额外的通信。 通信的方式其实非常原始，简单的发布订阅模式，利用 Chrome 插件提供的 API，分别在每个地方 set up 自己的 listener，并处理相应的事件即可。 发布向 Background 发送消息时可以使用 chrome.runtime.sendMessage，而向 Content 或 Frame 发送消息时，由于需要指定对应的 Tab（标签页），需要使用 chrome.tabs.sendMessage 订阅三个部分的 listener 都可以使用 chrome.runtime.onMessage 来完成事件监听。有一个需要注意的是，sendMessage 和 onMessage 有一个回调的功能，能使消息发送方接收订阅方的回调（类似于回执一样），看下例子： // 在 Content 发送消息chrome.runtime.sendMessage(&#123;greeting: \"您好\"&#125;, response =&gt; &#123; console.log(response.farewell);&#125;);// 在 Background 订阅消息chrome.runtime.onMessage.addListener((request, sender, sendResponse) =&gt; &#123; console.log(sender.tab ? \"来自内容脚本：\" + sender.tab.url : \"来自扩展程序\"); if (request.greeting == \"您好\") &#123; sendResponse(&#123;farewell: \"再见\"&#125;); &#125;&#125;); 可以看到订阅方是可以通过一个 sendResponse 的回调把数据回送给发送方，而由于我们在三个地方都监听了事件（调用了 chrome.runtime.onMessage.addListener），而文档上有说明 注意： 如果多个页面都监听 onMessage 事件，对于某一次事件只有第一次调用 sendResponse() 能成功发出回应，所有其他回应将被忽略。 因此需要合理的规划事件，保证同一类型的事件只会被某一个 listener 所处理，这样才能正确地调用 sendResponse 获取回送的数据。 规划事件为了使所有的事件能更好地分门别类，发送事件时使用了这样的数据格式： &#123; direction: 'content_to_background', area: 'frame', operate: 'decrease_active_tabs', options: &#123; task_id: 'c10103' &#125;&#125; direction - 说明当前事件的流动方向，用于在 listener 处进行筛选事件进行处理 area - 表明当前事件的处理器（或者模块） operate - 事件类型 options - 自定义参数 通过 direction 可以是三部分的 listener 定义复用到一个文件中： chrome.runtime.onMessage.addListener((message, sender, callback) =&gt; &#123; /** * area 表示操作的区域 */ const &#123; direction &#125; = message switch (direction) &#123; case 'background_to_content': case 'frame_to_content': this.contentListening(message, callback) break case 'content_to_background': case 'frame_to_background': this.backgroundListening(message, callback) break case 'content_to_frame': case 'background_to_frame': this.frameListening(message, callback) default: console.log('who cares ?') &#125; return true // 只有当return true的时候，callback才会将信息返回&#125;) 再根据 area 分别调用不同的 handler contentListening(message, callback) &#123; const &#123; area &#125; = message switch (area) &#123; case 'frame': frame.handle(message, callback) break case 'selector': selector.handle(message, callback) break &#125;&#125; 最后在具体处理的 handler 中根据事件类型 operate 分配处理的函数 // 处理 Frame 相关操作的 Handlerclass Frame &#123; constructor(frame_id) &#123; this.frame_id = frame_id this.frame = null &#125; handle(message, callback) &#123; const &#123; operate, options &#125; = message switch (operate) &#123; case 'move': this.move(options.position) break case 'change_width': this.changeWidth(options.type) break case 'toggle_width': this.toggleWidth() break // 更多的事件类型 &#125; &#125; // 省略具体的处理...&#125; Ajax 请求可以在 content script 或 background 中发对应的 ajax 请求，两者都能带上对应的 cookies，也没有受到同源策略的影响。但在实践中发现，对于在一些 HTTPS 站点中打开的插件，如果使用 content script 请求 HTTP 的后端接口，会报错。 Mixed Content: The page at ‘…’ was loaded over HTTPS, but requested an insecure resource ‘’. This request has been blocked; the content must be served over HTTPS. 因此还是把 ajax 请求放到了 background 的 js 环境中作请求，在 Vue 中封装了一个 $ajax 方法： Vue.prototype.$toBackground = function (message) &#123; return new Promise(resolve =&gt; &#123; chrome.runtime.sendMessage(&#123; ...message, direction: 'frame_to_background' &#125;, res =&gt; &#123; resolve(res) &#125;) &#125;)&#125;Vue.prototype.$ajax = async function (options) &#123; const result = await this.$toBackground(&#123; area: 'ajax', operate: 'request', options &#125;) &#125; return result&#125; 同时在 background 的 listener 中配置好 area 为 ajax 的 handler，这样就可以通过通信在 background 环境请求后端接口了。 日常开发配置在开发 Chrome 插件的时候，其实大部分时间都是在开发页面（Vue.js 部分），因此每次都 build 到本地，到 Chrome 扩展商店刷新，大大降低了效率。因此可以通过检查当前环境是否为插件环境，来禁止调用一部分插件环境才支持的 API，从而达到在普通 Web Server 中开发 Vue.js 页面的需求。 // 判断当前的环境是否是插件环境export const is_extension_env = window.location.protocol === 'chrome-extension:'// 对所有使用了插件 API 的地方进行配置Vue.prototype.$toBackground = function (message) &#123; return new Promise(resolve =&gt; &#123; if (is_extension_env) &#123; chrome.runtime.sendMessage(&#123; ...message, direction: 'frame_to_background' &#125;, res =&gt; &#123; resolve(res) &#125;) &#125; else &#123; resolve(&#123;&#125;) &#125; &#125;)&#125;// 如果是普通环境，直接调用 ajax 请求不需要通过消息Vue.prototype.$ajax = async function (options) &#123; let result if (!is_extension_env) &#123; result = await new Promise(resolve =&gt; request.handle(&#123; options &#125;, resolve)) &#125; else &#123; result = await this.$toBackground(&#123; area: 'ajax', operate: 'request', options: options &#125;) &#125; return result&#125; 这样就可以直接使用 npm run dev 打开网页进行普通的 Web 网页开发调试了。当然一些需要用到 chrome.* API 的功能还是需要进行 build 后实际调试。 参考资料 入门：建立 Chrome 扩展程序","tags":[{"name":"前端","slug":"前端","permalink":"https://blog.imtouch.info/tags/前端/"},{"name":"Chrome","slug":"Chrome","permalink":"https://blog.imtouch.info/tags/Chrome/"}]},{"title":"再谈微信小程序登录态维护","date":"2018-06-15T08:15:11.000Z","path":"2018/06/15/wechat-miniprogram-login-state/","text":"在之前的文章小程序 Page 获取登录态，异步满天飞？中，曾经讨论了一番微信小程序中登录态的获取维护与具体页面的业务数据接口调用之间的关系，由于无法保证登录逻辑与业务接口的时序性（而业务接口又必须依赖登录逻辑的完成才能获取 Token 进行验证），因此当时使用了类似 EventBus 的方法来串行化，使业务接口必须等待全局登录逻辑完成。 这样的方案不仅侵入性高，而且当业务页面变得越来越多时，EventBus 事件与回调的维护将变得一团糟。因此经过与 Gayhub 大神的探讨后，整理出这样的一套方案。 背景：登录态与第三方 Session 的获取维护对于微信小程序的应用来说，有两个需要维护的状态，一个是微信的登录态，另一个第三方 Session 的状态，先看微信官方的登录态时序图： 微信官方登录态时序图 结合 API 文档可以知道，通过 wx.login 和 wx.checkSession 两个前端接口来进行刷新和维护；而第三方 Session 的获取就是整个登录态中的某一步：在调用第三方开发者服务器用 code 换取 openid 的接口中返回我们自己定义的登录态（即第三方 Session）。 换言之，如果是第三方 Session 过期了，我们可以完全可以直接重新走一遍这个登录态流程来同时刷新微信登录态和第三方的登录态，而不需要独立进行第三方的刷新。 产生了问题：业务接口与登录逻辑的时序按照登录态时序图来实现整个登录逻辑本来是没有问题的，一般来说我们会在一开始进入小程序时就进行登录态的获取，换言之，就是在 App 的 onLaunch 事件中执行这个登录逻辑。但注意到登录时序中有一步： wx.request 发起业务请求，携带自定义登录态 一般来说，这些业务请求是放在了各个 Page 里面进行的，换言之，这个数据的获取是在 Page 的 onLoad 等事件里执行的。这样就会产生一个先后顺序的问题，详细介绍请看上一篇文章《小程序 Page 获取登录态，异步满天飞？》。 总之， 这种采用登录逻辑与业务逻辑分离的做法会带来很多不必要的代码冗余（包括处理 EventBus 事件的代码），能不能有一种方法可以优雅地解决这个问题呢？使 Page 只需要关注业务逻辑，到后端拿数据只是一段简单的函数调用而不必关注登录态？ 通过中间层屏蔽登录逻辑统一的后端中间层当我把这个问题发到 Github 上后，有同学提出了这样一种解决方案：对所有的 request 路由到一个中间层，通过中间层来处理登录逻辑。 Amazing~当我们重新审视这个问题的出现原因时，我们发现正是由于我们把整个登录态逻辑放在两个时序不相关的地方：App.onLaunch 和 Page.onLoad。那么为什么一定要进入小程序时就需要执行登录态获取的逻辑呢？只需要确保在执行请求的时候成功获取登录态与第三方 Session 就可以了。这样一来就可以严格地控制登录态与业务请求的先后顺序，不会出现业务请求时，token 为空的情况了。 根据这个思路，每一个 request 都会执行这样的一个流程图： 总体流程图 对于每一个请求，都去判断一下登录态的情况，如果发现没有登录，则执行相应的登录逻辑，登录逻辑的细节是这样的： 登录逻辑流程图 整个逻辑其实就是 A/B/C 三个函数调用，C 的流程是根据微信官方时序实现的，并且加入了获取个人信息部分，因为大部分的第三方登录接口都需要保存诸如微信头像地址等个人信息。 代码实现小程序 API Promise 化由于小程序提供的 API 全是回调函数的方式，在实现上文提到的 C 流程时会导致典型的回调地狱，因此首先需要一个把小程序 API 都返回 Promise 的 Wrapper. const promisify = wxMethod =&gt; options =&gt; new Promise((resolve, reject) =&gt; &#123; const extendOptions = Object.assign(&#123; success(res) &#123; resolve(res); &#125;, fail(res) &#123; reject(res); &#125; &#125;, options); wxMethod(extendOptions);&#125;);class WeixinWrapper &#123; login = promisify(wx.login); request = promisify(wx.request); getSetting = promisify(wx.getSetting); getUserInfo = promisify(wx.getUserInfo); checkSession = promisify(wx.checkSession);&#125;const weixinWrapper = new WeixinWrapper();export default weixinWrapper; 这样就可以使用 Promise 来处理了，方便很多。 request 实现对于后端请求的统一入口 request，按照流程图进行实现，这里登录逻辑里的三个方法 A/B/C 返回的都是 Promise A - 检查微信登录态：checkWxSession B - 检查第三方 Session 态：checkThirdSession C - 登录逻辑：doLogin 检查都通过后，将 store 中的 token 放到每个 request 的 Header 中即可实现业务请求带上自定义登录态的需求了。 const request = (method, url, data, header = &#123;&#125;) =&gt; new Promise(async (resolve, reject) =&gt; &#123; try &#123; const thirdSessionChecked = await checkThirdSession(); const wxSessionChecked = await checkWxSession(); if (!(wxSessionChecked &amp;&amp; thirdSessionChecked)) &#123; await doLogin(); &#125; const customHeader = header; if (store.state.token) &#123; customHeader.Authorization = `Bearer $&#123;store.state.token&#125;`; &#125; const res = await wxWrapper.request(&#123; method, url: url.startsWith('http') ? url : apiPrefix + url, data, header: customHeader &#125;); if (res.statusCode &gt;= 200 &amp;&amp; res.statusCode &lt; 300) &#123; resolve(res.data); &#125; else &#123; reject(res); &#125; &#125; catch (err) &#123; reject(err); &#125;&#125;); 三个方法登录逻辑中三个方法的实现就直接根据逻辑来实现就好了，注意都返回 Promise 就行了，这里就不贴出全部代码了，大致看下 doLogin 的结构。 const doLogin = (globalUserInfo = &#123;&#125;) =&gt; new Promise((resolve, reject) =&gt; &#123; let customOpenId; let headImg; let fullUserInfo; wxWrapper.login() // 1. 获取微信登录态 .then((&#123; code &#125;) =&gt; wxWrapper.request(&#123; // 2. 换取 openid url: `$&#123;wxApiPrefix&#125;/v1/openId/$&#123;code&#125;`, method: 'GET', data: &#123; type: 'xcx' &#125; &#125;)) .then((&#123; data: &#123; code: openCode, data: openid &#125;, statusCode: openidCode &#125;) =&gt; &#123; customOpenId = openid; if (openidCode === 200 &amp;&amp; openCode === 1) &#123; return wxWrapper.getSetting(); // 3. 检查是否授权 &#125; throw new Error(); &#125;) .then((&#123; authSetting &#125;) =&gt; &#123; if (authSetting['scope.userInfo']) &#123; return wxWrapper.getUserInfo(&#123; // 4. 获取个人信息 withCredentials: true, &#125;); &#125; throw new Error(); &#125;) .then((userInfo) =&gt; &#123; fullUserInfo = userInfo; headImg = fullUserInfo.userInfo.avatarUrl; headImg = `$&#123;headImg.substr(0, headImg.lastIndexOf('/'))&#125;/46`; return wxWrapper.request(&#123; // 5. 第三方登录 url: `$&#123;apiPrefix&#125;/auth/wx`, method: 'POST', data: &#123; clientType: 'xcx', headImg, nickname: fullUserInfo.userInfo.nickName, sex: fullUserInfo.userInfo.gender, xcxOpenid: `$&#123;customOpenId&#125;`, realname: globalUserInfo.realname &#125;, &#125;); &#125;) .then((&#123; data: &#123; code: authCode, data: token &#125;, statusCode: tokenCode &#125;) =&gt; &#123; if (tokenCode === 200 &amp;&amp; authCode === 1) &#123; const now = Date.now(); const user = &#123; openid: customOpenId, nickname: fullUserInfo.userInfo.nickName, headImg, realname: globalUserInfo.realname &#125;; store.commit('setToken', token); store.commit('setTokenGenTime', now); store.commit('setUser', user); wx.setStorageSync('token', token); wx.setStorageSync('token_gen_time', now); wx.setStorageSync('user', user); resolve(); &#125; throw new Error(); &#125;) .catch(() =&gt; &#123; reject(); &#125;);&#125;); 新的问题：并发业务接口导致多次进入登录逻辑通过一个统一的 request 方法，把所有到后端业务的接口路由在一起并处理登录态很好的解决了之前提到的执行时序的问题。但会导致两个新的问题： 当页面中并发两个 request 时，由于登录逻辑是异步的，就会有可能出现两个 request 都进入了登录逻辑。不仅浪费了网络资源，而且还有可能导致个人敏感信息的解密出错。 执行过登录逻辑后的状态没有保存起来，上文的 request 实现是无状态的，那意味着以后每次调用 request 都会调用 wx.checkSession 进行微信登录态的检查，而这不是我们希望看到的，检查过以后在当前小程序的生命周期里就不应该再去检查了。 因此我们需要一个类似锁的东西，让代码在登录逻辑中只执行一次，如果执行过了立即返回，没执行过就马上执行，执行中则等待。 Promise.race没错！只需要用 Promise.race - MDN 就能快速地解决掉上面的问题！ 什么是 Promise.race 直白地解释下，就是传入一个 Promise 数组，返回一个新的 Promise，当且仅当数组中有一个 Promise resolve 了，新的 Promise 才会 resolve. // MDN 上的例子：简单明了var p1 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 500, \"one\"); &#125;);var p2 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 100, \"two\"); &#125;);Promise.race([p1, p2]).then(function(value) &#123; console.log(value); // \"two\" // 两个都完成，但 p2 更快&#125;);var p3 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 100, \"three\");&#125;);var p4 = new Promise(function(resolve, reject) &#123; setTimeout(reject, 500, \"four\"); &#125;);Promise.race([p3, p4]).then(function(value) &#123; console.log(value); // \"three\" // p3 更快，所以它完成了 &#125;, function(reason) &#123; // 未被调用&#125;);var p5 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 500, \"five\"); &#125;);var p6 = new Promise(function(resolve, reject) &#123; setTimeout(reject, 100, \"six\");&#125;);Promise.race([p5, p6]).then(function(value) &#123; // 未被调用 &#125;, function(reason) &#123; console.log(reason); // \"six\" // p6 更快，所以它失败了&#125;); 改造登录逻辑由于第三方 Session 状态检查相对较轻，也可以允许并发重入，因此就不需要改造。而调用 wx.checkSession 检查小程序登录态则可以使用 Promise.race 改造一下。 const checkWxSession = () =&gt; &#123; if (checkWxSessionPromise) &#123; return Promise.race([checkWxSessionPromise]); &#125; checkWxSessionPromise = new Promise((resolve) =&gt; &#123; wxWrapper.checkSession().then(() =&gt; &#123; resolve(true); &#125;).catch(() =&gt; &#123; resolve(false); &#125;); &#125;); return checkWxSessionPromise;&#125;; 同理，实际的登录逻辑 doLogin 也可以通过这样「缓存」起 Promise 来实现只执行一次，但需要注意的是，由于当 Promise 生成后就不再进入实际的登录逻辑了，当登录成功或失败时，需要重置缓存的 Promise 对象。另外检查微信登录态的缓存也需要更新。 const doLogin = (globalUserInfo = &#123;&#125;) =&gt; &#123; if (loginPromise) &#123; return Promise.race([loginPromise]); &#125; loginPromise = new Promise((resolve, reject) =&gt; &#123; // ... 省略具体的业务代码 wxWrapper.login().then(() =&gt; &#123; // 允许以后重入 doLogin loginPromise = null; // 缓存起小程序登录态，登陆成功就默认返回 true checkWxSessionPromise = Promise.resolve(true); resolve(); &#125;).catch(() =&gt; &#123; // 允许以后重入 doLogin loginPromise = null; reject(); &#125;) &#125;); return loginPromise;&#125; 总结微信小程序的开发中需要处理微信本身的登录态与第三方的登录态，因此整个状态的保持与维护逻辑都相对较为复杂，这里还没有涉及到只刷新第三方登录态的情况（微信登录态未过期第三方登录态过期），而是统一为无论谁过期了统一两个状态一起刷新。这样的处理在效率和复杂度来说应该是可以接受的。 另外如果小程序中不需要接入微信，比如是一个需要账号密码登录的应用，那就可以完全不使用 wx.login 这种接口来维护微信的登录态了，自己维护即可。 参考资料 Github 上的讨论 小程序 - 官方文档 wx.login weRequest","tags":[{"name":"小程序","slug":"小程序","permalink":"https://blog.imtouch.info/tags/小程序/"},{"name":"前端","slug":"前端","permalink":"https://blog.imtouch.info/tags/前端/"}]},{"title":"使用 mpvue 开发微信小程序记录","date":"2018-04-26T03:16:35.000Z","path":"2018/04/26/wechat-mpvue-log/","text":"本文记录了使用 mpvue 开发微信小程序时遇到的一些问题及解决方法。 获取页面路由参数官方文档写得很清楚，引用一下。 1. 如何获取小程序在 page onLoad 时候传递的 options 在所有 页面 的组件内可以通过 this.$root.$mp.query 进行获取。 2. 如何获取小程序在 app onLaunch/onShow 时候传递的 options 在所有的组件内可以通过 this.$root.$mp.appOptions 进行获取。 Page 背景色一开始以为在 Vue 组件里把根元素的背景色和 Page 的 option 设置好就可以了，比如这样 &lt;template&gt; &lt;div class=\"container\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .container &#123; background-color: #EEEEEE; &#125;&lt;/style&gt; // main.jsimport Vue from 'vue';import MyPage from './my_page';const app = new Vue(MyPage);app.$mount();export default &#123; config: &#123; navigationBarTitleText: '某个页面', backgroundColor: '#EEEEEE' &#125;,&#125;; 这样只有 .container 所在的 div 是有背景色的，如果 .container 没有被撑开到一个页面这么大，page 的背景色还是白的，因此需要全局设置 page 的背景色 page &#123; background-color: #F4F5F5;&#125; template 不支持函数mpvue 的文档中提到： 不支持在 template 内使用 methods 中的函数。 那就会带来很大的不方便，比如有的时候需要在一个 v-for 里根据某些条件来显示或隐藏某个 dom &lt;div class=\"option\" v-for=\"(option, index) in options\"&gt; &lt;span&gt;&#123;&#123;option.name&#125;&#125;&lt;/span&gt; &lt;span v-if=\"selectedOptionIds.includes(option.id)\"&gt; &lt;img src=\"/static/img/tick.png\" alt=\"\"&gt; &lt;/span&gt;&lt;/div&gt; 这里的 selectedOptionIds 是一个 id 数组，如果当前项被选中了就显示一个打钩的图片，虽然没有使用 methods 里的函数，但这里这样写依然是不行的（不知道是 mpvue 的 bug 还是的确不支持）。 当我的 seletedOptionIds 是一个单元素数组的时候，直接把 v-if 改成 selectedOptionIds == option.id，效果就出来了，看来的确是用了一个函数的问题。 可以通过再新建一个变量来解决，这种动态判断说到底其实也是可以在初始化的时候把判断的 flag 值先算好，然后再 template 里通过 flag 判断。 &lt;template&gt; &lt;div class=\"option\" v-for=\"(option, index) in options\"&gt; &lt;span&gt;&#123;&#123;option.name&#125;&#125;&lt;/span&gt; &lt;span v-if=\"flags[index]\"&gt; &lt;img src=\"/static/img/tick.png\" alt=\"\"&gt; &lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; options: [], selectedOptionIds: [], flags: [] &#125;; &#125;, onShow() &#123; // 初始化 options/seletedOptionIds ... // 初始化 flags this.flags = this.options .map(option =&gt; option.id) .map(id =&gt; this.selectedOptionIds.includes(id)); &#125; &#125;&lt;/script&gt; v-if/v-show由于 v-if 会实际地创建和销毁对应的 DOM，而 v-show 总是创建节点，有些时候会导致一些样式上的问题，特别是在 DOM 节点上有动态的样式绑定时。 在性能方便需求不高时，可按需使用 v-if 或 v-show。 px/rpxmpvue-loader 中用到了 px2rpx-loader 会自动把 style 里的 px 单位自动转成小程序的 rpx 单位，有些使用我们并不希望使用相对的 rpx 单位，目前还没有找到什么切实的解决方法。 另外，px2rpxLoader插件这里提到的改变 loader 顺序的方法并没有什么用，会报错。全部转换的影响也不会很大。 允许页面分享mpvue 默认对所有页面都开了分享，如果不想当前 Page 出现分享菜单，可以参考如何在vue中设置去掉转发功能里的做法。 // FIXME mpvue 对所有页面默认开了分享，不分享的 workaroundonShareAppMessage() &#123; return &#123;&#125;;&#125;,onLoad() &#123; wx.hideShareMenu();&#125;, 新版本 mpvue 已经取消了对所有页面开启分享，只有定义了 onShareAppMessage 方法才会开启分享 TimePicker 国际化小程序提供了一个 mode=time 的时间 picker，一般来说不会导致什么很大的问题。但由于这个 picker 直接调的是系统的时间选择，在 iOS 下如果用户的语言选了日语，这时 picker 拿到的 value 就不再是 HH:mm 这种格式了，而是像 &#39;14午後2:30&#39; 这样的字符串，构造出来的 Date 字符串后端解析不了便报错了。 解决办法是直接使用 mode=multiSelector 的多列 picker 替换掉时间选择器，自定义 hour 和 minute 列（0~23, 0~59），不再依赖系统语言的时间。 &lt;picker class=\"time-picker\" mode=\"multiSelector\" :range=\"timeRange\" :value=\"vote.deadlineTime\" @change=\"onTimeChange\"&gt; &lt;div class=\"time-value\"&gt; &#123;&#123;vote.deadlineTime[0] + ':' + vote.deadlineTime[1]&#125;&#125; &lt;/div&gt;&lt;/picker&gt;","tags":[{"name":"小程序","slug":"小程序","permalink":"https://blog.imtouch.info/tags/小程序/"},{"name":"Vue","slug":"Vue","permalink":"https://blog.imtouch.info/tags/Vue/"}]},{"title":"LeetCode 题解一","date":"2018-04-11T06:58:40.000Z","path":"2018/04/11/leetcode-idea-1/","text":"LeetCode 题解一。 621 Task Scheduler题目大意：CPU 调度，给一串用 Char 表示的任务列表，一个周期运行一个，规定相同两个任务之间的运行间隔不能超过 n，求最少需要多少个周期能跑完。 由于任务之间应该是互相独立的，所以就用贪心算法吧，每次从可以运行的任务中拿一个出来跑，并记下最近一次的运行时间（判断能否运行这个任务时用到），一直循环直到完成所有任务。 需要两张 k-v 表，一张记录最近运行的时间 last，一张记录当前所有任务还剩多少次没完成 remain，每轮循环找可运行的任务： remain[task] &gt; 0 &amp;&amp; last[task] + n &lt; current 这样会报 EA，想了一下贪心有点问题，对于一些高频任务应该高优先级执行，跟实际操作系统是类似的，因此在遍历 remain 表的时候应该按剩余次数从大到小遍历： for(let entry of Object.entries(remain).sort((p, n) =&gt; p[1] &lt; n[1])) &#123; // ...&#125; 最后判断任务是否做完可以直接查 remain 表看看是否各项都是 0，但可以再额外建一个变量表示实际任务运行的次数，这样每次判断就快多了。 623 Add One Row to Tree题目大意：给一个二叉树，在第 d 层添加一行节点，每个节点的值为 v 题目其实把算法都写清楚了，对所有在第 d-1 层的非空节点，都新建两个子节点，把原左子树作为新左孩子的左子树；原右子树作为新右孩子的右子树，即： const newLeftNode, newRightNode;newLeftNode.left = node.left;newRightNode.right = node.right;node.left = newLeftNode;node.right = newRightNode; 因此思路就是用队列做层次遍历，到树高为 d-1 时处理一下，直接把原 root 返回，原地变换。 再处理一下边界条件（d = 1 或树高+1）就可以了。 628 Maximum Product of Three Numbers题目大意：给一个整数数组，找出三个数，乘积最大 乍一看这不是有点简单吗，遍历一遍找出最大的三个数，乘一下就好了啊，然后就疯狂 WA… 有各种 Corner Case 要处理.. 结果三个数的情况最后选出的结果肯定是三个数，这三个数的符号只有 4 种情况： 正正正：三个正数只要找最大的三个数相乘就行了 正正负：这三个数乘积是负的，什么情况下会出现呢？考虑加入一个正数，此时数组里的情况是「正正负正」，那么三个正数的乘积必定比负数要大，不会选出「正正负」；考虑加入一个负数，此时数组里的情况是「正正负负」，那么可以通过选择「正负负」来使最终结果为正数，也不会选出「正正负」。因此选出这三种数的唯一情况是：只有三个数，这三个数的符号分别为「正正负」。 正负负：乘积为正，找最大的正数和绝对值最大的两个负数就行了 负负负：乘积为负，同样考虑什么情况出现。考虑加一个正数，此时「负负负正」，不会选出「负负负」；加一个负数，此时「负负负负」，负数需要找绝对值最小（也就是最大）的三个数乘积 所以额外处理 2 和 4，其他情况结果就是 1、3 中的最大值。 0 的处理这样下来还是不能 AC，对于 [0, 0, 0, 4] 没处理好，这里通过计算非 0 数字个数再来处理： 3 个或以上非 0 数字，就是前面的情况 3 个以下非 0 数字，结果必为 0，因为一定会选到 0 这样就 ok 了。","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.imtouch.info/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"https://blog.imtouch.info/tags/算法/"}]},{"title":"JavaScript 中的隐式类型转换的规范","date":"2018-04-02T02:29:09.000Z","path":"2018/04/02/implicit-type-conversion-in-javascript/","text":"本文从 ECMAScript 规范的角度尝试征服 JavaScript 的真值表！全文都是规范，不要方，正面刚！ 小试牛刀如果你能把下面的所有题目都答对并解释清楚来龙去脉，恭喜你，你已经是大神级别了！答案就请自行找个 Console 实际敲敲，Believe me，你会大吃一斤的。 // 每个表达式是 true 还是 false 呢？为啥呢？// 初阶!&#123;&#125;12 == '12''false' == falsenull == undefined// 高阶[] == [][] == false[] === false[45] == 45// 终阶[45] &lt; [46][10] &lt; [9]&#123;&#125; == !&#123;&#125;&#123;&#125; != &#123;&#125;-0 === +0NaN === NaNNaN != NaN 深入规范江湖传闻 JavaScript 有张让人闻风丧胆的真值表，我觉得吧只要把每种类型是怎么判断的弄清楚，其实是不需要去记忆这样的表的。因此我们需要了解规范里是怎么处理这些表达式的。 JavaScript 真值表 规范中关于上面那堆表达式是怎样求值的有好几处地方的说明，包括 7.1 Type Conversion 7.2 Testing and Comparison Operations 12.5.9 Logical NOT Operator ( ! ) 12.10 Relational Operators Type ConversionBuilt-in Types这部分规定了不同 Type 之间转换时，应该如何进行转换。在此之前需要了解 ECMAScript 到底定义了多少种 Type？ ECMAScript 一共定义了七种 built-in types，因此在节 6.1 ECMAScript Language Types 共有七个小节，分别详细解释七种类型。 其中六种类型为 Primitive Value.（余文所有加粗的类型均表示 ECMAScript Language Type，没有加粗表示 JavaScript 中的类型） A primitive value is a member of one of the following built-in types: Undefined, Null, Boolean, Number, String, and Symbol; an object is a member of the built-in type Object; and a function is a callable object. 想去了解详情的可以去看看规范，里面关于 Number 类型的解释会让人豁然开朗的。这里只需要知道 null 这个值是属于 Null 类型，而 undefined 是属于 Undefined 类型的。 另外这里的 Object built-in type 跟我们平常理解的 JavaScript 里的 Object 并不一样，总的来说只要不属于 Primitive Value 的值，就属于 Object 类型。比如开发中常见的数组、对象、Date、RegExp 等在 ECMAScript 中均属于 Object 类型。 ToPrimitiveToPrimitive 用于将 Object 转为 Primitive Value ToPrimitive 先忽略那堆 preferredType 的东西，对于平常遇到的对象（Object）来说，基本上都是 Ordinary 的，所以其实就是默认了 hint = number 再去调用 OrdinaryToPrimitive。 OrdinaryToPrimitive 由于进来的 hint 是 number 所以这个转换就是： 调用 Object.valueOf，如果结果是 Primitive Value，则返回 调用 Object.toString，如果结果是 Primitive Value，则返回 都不是，返回 TypeError 如果看过红宝书的话，里面其实也讲到这部分内容，这里可以从规范的角度再一次说明。 然后来看看普通对象和数组的这两个方法返回的是什么。 var a = [12]var b = &#123;a: 123&#125;// [12]a.valueOf()// '12'a.toString()// &#123;a: 123&#125;b.valueOf()// '[object Object]'b.toString() 可以看到两者的 valueOf 返回的都不是 Primitive Value（返回了自身，还是属于 Object 类型），根据规范两者调用 ToPrimitive 返回的将是一个字符串，这一点非常重要。 ToBoolean这个方法用于将不是 Boolean 类型的值转换为 Boolean 类型。 ToBoolean 注意几点就可以了： 所有 Object 类型都会被转换为 true Number 类型中的 0、NaN 会被转换为 false，其他都是 true 只有空串才为 false，其他都是 true（&#39;false&#39;/&#39;0&#39; 之类的不要搞错） ToNumber同理，其他类型转换为 Number 类型。 ToNumber 有比较诡异的几点： undefined 会被转为 NaN；而 null 是转为 +0 true 转为 1；false 转为 +0（这个很重要） String 的转换策略不是本文的重点，可以先理解为满足数字语义（即规范下文的 StringNumericLiteral）的就转换成数字，不符合就是 NaN Object 类型的转换，看到了我们的老朋友 ToPrimitive 了没？先转成 Primitive Value，再递归调用自身 ToNumber 来做转换的 到了这一步，看看是否理解了？ // '56' ==&gt; 56Number([56])// ',56' ==&gt; NaNNumber([,56])// '55,56' ==&gt; NaNNumber([55, 56]) 这里的转换是分两步的，先转换成字符串，再转换成数字，这个很重要。 Logical NOT Operator了解完上面几个转换后就可以来看那一堆表达式了！首先是简单点的单目逻辑非，规范是这样的： Logical NOT Operator 哇哦，就是直接调用了 ToBoolean，然后取反返回。 // [] ==&gt; true; false![] // &#123;&#125; ==&gt; true; false!&#123;&#125;// NaN ==&gt; false; true!NaN 嗯，应该没什么大问题。 Comparison Operations大 boss 来了，有不少文章都有介绍 == 和 === 的异同，直接看规范依然是最好的。 Evaluation Evaluation GetValue 就是计算一下表达式的值，== 和 === 的结果重点在 Abstract Equality Comparison 和 Strict Equality Comparison 这两个操作里。 另外 != 和 !== 则是指出了 A != B 与 !(A == B) 是完全等价的。在判断 !=/!== 时，其实就是在判断 ==/===. Abstract Equality Comparison Abstract Equality Comparison 好长啊，不要慌，中文翻译一下： 如果 Type 相同，等价为 A === B 特别地，undefined == null String == Number，则把 String 转换成 Number 有 Boolean 值的，将 Boolean 转换成 Number Object == String/Number/Symbol，将 Object 转换成 Primitive Value 否则，返回 false 结合小试牛刀的例子来说明 // '12' ==&gt; 12; // 返回 true12 == '12'// 转 boolean: [] == 0// 转 object: '' == 0// 转 string: 0 == 0// 返回 true[] == false// 转 object: '45' == 45// 转 string: 45 == 45// 返回 true[45] == 45// 单目: &#123;&#125; == false// 转 boolean: &#123;&#125; == 0// 转 object: '[object Object]' == 0// 转 string: NaN == 0// 返回 false&#123;&#125; == !&#123;&#125; 可能有部分同学对于 [] == false 的转换过程中居然会出现 &#39;&#39; == 0 这一步感到诧异，啊！空数组不是直接就转成数字 0 的吗，然后跟 0 比较的吗？ 同样使人困惑的还有 0 == {} 这个转换过程中会出现的 &#39;[object Object]&#39; ，原因是，最后将 Object 转换为 Primitive Value 调用的 ToPrimitive，在前文已经提到，对于数组和普通对象而言，转换出来的是 String，而不是 Number。为了证明这一点，我们尝试改写 Object 或 Array 上的 valueOf 方法和 toString 方法。 console.log([] == false)Array.prototype.toString = function () &#123; return '1'&#125;console.log([] == false)console.log([] == 1) 可以看到两次的输出是不一样的，覆盖了默认的 toString 方法后，[] == 1 输出了 true，因为此时数组的 ToPrimitive 方法返回的是字符串 &#39;1&#39;，同理 Object 的情况也是如此。（顺便可以验证 valueOf 确实是优先于 toString 方法的） console.log('[object Object]' == &#123;&#125;)Object.prototype.toString = function () &#123; return '1'&#125;Object.prototype.valueOf = function () &#123; return '2'&#125;console.log('[object Object]' == &#123;&#125;)console.log(1 == &#123;&#125;)console.log(2 == &#123;&#125;) Strict Equality Comparison Strict Equality Comparison 类型不同，直接返回 false Number 类型判断：有 NaN 就 false；+0 === -0； 最后调用 SameValueNonNumber SameValueNonNumber 总的来说，严格相等没有非严格相等这么多情况跟转换（毕竟就是同一类型了），记住了 NaN 的 corner case 和对象引用本身相等才是 true 就 ok 了。 // 类型相同，等价于 [] === []// 返回 false[] == []// 等价于 !(&#123;&#125; == &#123;&#125;)// 等价于 !(&#123;&#125; === &#123;&#125;)// 返回 true&#123;&#125; != &#123;&#125;// 等价于 !(NaN == NaN)// 等价于 !(NaN === NaN)// 返回 trueNaN != NaN// 类型不同，返回 false[] === false Relational Operators搞掂了相等，不等怎么办？不等关系是由 Abstract Relational Comparison 定义的。 Abstract Relational Comparison 这个是真的长，其实注意两点就可以了 两边操作数调用 ToPrimitive 转换为 Primitive Value 由于 Primitive Value 出来有 String 和 Number 两种结果，分别有不同的比较规则；String 按 code unit 比较，Number 需要处理 +0/-0/NaN/Infinity 等情况 解释下上面的题目 // 注意转换后为 '45' &lt; '46'// 按字符串规则比较，返回 true[45] &lt; [46]// 同理 '10' &lt; '9'，则是返回 false[10] &lt; [9] 指导意义了解这些对实际开发工作有什么现实意义吗？额，很可能是没有的，大多都是各种面试题（笑。 但了解背后的原理对于一些关于类型转换带来的 Bug 的定位和如何去做实际编码中的最佳实践能提供很大的帮助。举两个🌰 初始化订单吧。 if (!$scope.orders) &#123; $http.post('/api/orders', $scope.params).then(res =&gt; &#123; $scope.orders = res.data &#125;)&#125; 然而有人很有责任感地进行了数据初始化：$scope.orders = []，GG！ 用户没有选择状态就弹出提示。 if (!this.editForm.status) &#123; this.warning('请选择状态')&#125; 这不会是个数组了吧，很不幸，后端同学定义的 status 里有个 0…有个 0..有个 0. 参考 ECMAScript® 2017 Language Specification (ECMA-262, 8th edition, June 2017) 聊聊类型转换","tags":[{"name":"ECMAScript","slug":"ECMAScript","permalink":"https://blog.imtouch.info/tags/ECMAScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.imtouch.info/tags/JavaScript/"},{"name":"规范","slug":"规范","permalink":"https://blog.imtouch.info/tags/规范/"},{"name":"类型转换","slug":"类型转换","permalink":"https://blog.imtouch.info/tags/类型转换/"}]},{"title":"Leaflet MovingMarker 轨迹回放功能","date":"2018-03-12T03:42:33.000Z","path":"2018/03/12/leaflet-moving-marker/","text":"最近有一个关于地图轨迹回放的功能，使用了 Leaflet 的 MovingMarker 插件后仍有不少问题需要解决，本文介绍了实现这个需求的过程与方案。 来自产品的需求轨迹回放往大了讲其实有点像视频播放器，有一个可拖动的指示器，地图上就是一个移动的 marker.（这里有张 10M 的动图…） 有几点需要注意的： 播放过程中可以暂停，暂停后可以从当前位置继续播放 播放过程中可以拖动指示器，地图上的点也需要相应地出现在对应的位置，但动画会继续播放，就像拖动播放器的进度条一样 同上，暂停过程中也可以拖动指示器，但此时动画不再播放 方案1：直接动画轨迹其实就是对一个 Marker 做一个动画，用作展示，目前 Leaflet 已经有对应的移动点插件 MovingMarker，使用上也非常简单，传入一堆点坐标和持续时间，调用一下 start() 方法就马上有动画出来了。官网上的例子： var myMovingMarker = L.Marker.movingMarker([[48.8567, 2.3508],[50.45, 30.523333]], [20000]).addTo(map);myMovingMarker.start(); 这样就能实现地图上的一个可以移动的点。 但我们不光需要地图上的坐标点能够运动，还需要底下的指示器能根据地图点的移动作出相应的变化，比如移动到第二个点的时候，指示器也要同时显示为第二个点。 第一个想法就是通过事件来解决，在动画的过程中监听「移动到某个点」的事件，改变一下指示器的当前值就 ok 了。然而很不幸的是，MovingMarker 没有提供这样的事件，实际上 API 上有这样的一个事件： end: fired when the marker stops 但这个事件是在整段动画结束后才触发的，只会触发一次。举个栗子，如果有一段五个点的轨迹播放，只有当动画播放到最后一个点的时候才会触发这个 end 事件，在中途路过三个点的时候，啥事都没发生。 方案2：分段动画既然这个 end 事件会在动画结束时才触发，那马上想到的就是把整个轨迹的动画分解成每一段线段的动画，再按顺序播放就行了。在 end 事件触发的时候改一下指示器的 model 值，简直 nice，看了下还果真有这样的 API moveTo(latlng, duration): stops current animation and make the marker move to latlng in duration ms. 那思路就很清晰了，初始化 marker 为第一个点，然后调用 moveTo，开始到下一个点的动画，然后监听 end 事件，在事件处理函数中继续调用 moveTo 到下一个点，直到最后。顺便在 end 事件中，改变一下指示器的当前状态。 // 坐标点数组const points = [];// 当前所在点索引const cur = 0;// 指示器当前值let indicator = 1;const MOVE_TIME = 1000;marker.setLatLng(points[cur]);marker.moveTo(points[++cur], MOVE_TIME);marker.on('end', () =&gt; &#123; indicator = cur; if (cur &lt; points.length - 1) &#123; marker.moveTo(points[++cur], MOVE_TIME); &#125;&#125;); 逻辑上看没啥大问题，但实际出来的效果却是出现了丢帧的现象，中间有几段的动画不见了，点直接就跳过去了。经过一番摸索后，发现在 end 的事件处理中加上 setTimeout 后丢帧就解决了。 marker.on('end', () =&gt; &#123; setTimeout(() =&gt; &#123; indicator = cur; if (cur &lt; points.length - 1) &#123; marker.moveTo(points[++cur], MOVE_TIME); &#125; &#125;, 0);&#125;); 分别调用 .start() 和 .moveTo 的例子，在 moveTo 下勾选了 setTimeout 后，丢帧消失了 拖动指示器的困境回顾需求，我们发现其实我们只是把播放（暂停可通过 pause/resume 很好地实现）搞定了，在继续思考另外的需求怎么实现的时候，遇到了一个困境。 描述这个困境前，我们先把前面 marker 移动与指示器联动的具体细节说清楚。前面提到，指示器的当前状态指示一个变量 indicator，我们简单地在每次动画结束时做一个赋值 indicator = cur 就能完成这种联动了。假设我们使用的 MVVM 框架是 Angular 的话，这个指示器的 HTML 应该是类似这样的 &lt;indicator [ngModel]=\"indicator\"&gt;&lt;/indicator&gt; 绑定一个变量到组件里，嗯。 好，现在我们要实现拖动指示器的时候，marker 也能有所变化，那自然而然，给这个组件绑定个 change 事件吧，事件处理里改一下 marker 就好了！ &lt;indicator [ngModel]=\"indicator\" (ngModelChange)=\"onIndicatorChange()\"&gt;&lt;/indicator&gt; 在 Angular 里，ngModel 绑定的属性默认会有一个 ngModelChange 事件，在 model 改变的时候调用。写好所有逻辑后打开页面测试，连原来的连贯动画都出问题了！为啥呢！ 如何区分 model 的改变是因为拖动改变还是代码调用改变的呢？ 对于这个 indicator 组件来说，它只知道 indicator 是它的 model，只要 model 变化了就调用回调，因此它无法区分这个 model 的改变是什么引起的。无法区分就意味着这个需求实现不了啊。 方案3：声明式换种思路既然区分不了，那干脆就不区分了？仔细想想实现分段动画的方式，其实那是一种命令式的实现方式： 到第一个点 =&gt; 动画移动到第二个点 =&gt; 动画移动到第三个点 =&gt; … 使用命令式的方式来组织代码，往往以后逻辑复杂的时候会非常难以维护，那能不能以一种声明式的思路来组织呢？整个应用的 model 其实只有一个，就是当前所在的点，也就是说，一个 index，这个轨迹移动的过程应该是 index = 0 =&gt; index = 1 =&gt; index = 2 =&gt; … 至于页面上的元素如何变化（marker 需要移动、指示器需要变化），应该由一个关系来描述，那么当 model 变化时，相应的页面元素也能自动更新了。 使用 JavaScript 的 getter/setter 能很好地做到 _cur = 0;get cur() &#123; return this._cur;&#125;set cur(value) &#123; // 绑定对应的关系 this._cur = value;&#125; 这样实现后，end 事件就变得非常简单了，就是一个简单的索引自增，注意 setTimeout 还是需要的 marker.on('end', () =&gt; &#123; setTimeout(() =&gt; &#123; if (cur &lt; points.length - 1) &#123; cur++; &#125; &#125;, 0);&#125;); model 的逻辑在写里面的逻辑时，由于涉及到动画，那么当设置 index 的时候，会有两种动画策略： 执行从点 index 到点 index+1 的动画 执行从点 index -1 到点 index 的动画 其实两种实现方式都可以，但出于与指示器的 model 一致的考虑，这里我选择了第一种 set cur(value) &#123; // 绑定对应的关系 this._cur = value; // 先把 marker 设置为当前点 this.marker.setLatLng(this.points[value]); // 执行移动到下一个点的动画 if (value &lt; this.points.length - 1) &#123; this.marker.moveTo(this.points[value + 1], MOVE_TIME); &#125;&#125; 这里只是一个简单地示例，在实际场景还需要处理如播放、暂停等情况，还需要加上不同的 state 控制逻辑。这样把 cur 的逻辑写好后，指示器的 HTML 就可以直接写成 &lt;indicator [(ngModel)]=\"cur\"&gt;&lt;/indicator&gt; 直接做一个双向绑定就完了！所有的逻辑都放在了 setter 里，对于页面组件来说他们不再需要关心逻辑的细节，他们只需要知道 model 就可以了，这样的解耦使功能的实现和维护都更加的简单、清晰。","tags":[{"name":"Leaflet","slug":"Leaflet","permalink":"https://blog.imtouch.info/tags/Leaflet/"},{"name":"动画","slug":"动画","permalink":"https://blog.imtouch.info/tags/动画/"},{"name":"MVC","slug":"MVC","permalink":"https://blog.imtouch.info/tags/MVC/"},{"name":"声明式","slug":"声明式","permalink":"https://blog.imtouch.info/tags/声明式/"}]},{"title":"Date Format in JavaScript","date":"2018-03-07T02:30:40.000Z","path":"2018/03/07/date-and-timezone-in-javascript/","text":"俗话说得好，代码重构火葬场。最近接手了一个微信商城的项目，代码量不是很大，但其中还是有不少的坑可以深陷其中，包括一个关于 JavaScript 的 Date Format 问题。另外网上的很多文章在 Date Format 上的理解略有偏颇，因此结合着 ECMAScript 规范把这部分的知识整理一下。 时间与时区时区嘛，简单点讲就是地球上不同地方的时间是不一样的，其中存在一个标准时区的时间，我们叫 UTC 时间。中国位于东八区嘛，所以 CST（中国标准时间）就会比 UTC 快八小时。举个栗子： 如果标准时间是 2018-01-01 00:00:00，那么在中国的时间就应该是 2018-01-01 08:00:00，因为我们比较快嘛。相反，如果在中国的时间是 2018-01-01 00:00:00，那么标准时间就应该是 2017-12-31 16:00:00， 还没倒数新年呢。这个呢应该比较好理解。 怎样 Format 一个 DateISO 8601 &amp; Date Time String Format首先是 ISO 8601 其实是有非常非常多的日期时间定义方式的，而 ECMASCript 只用了一个 Simplified 版本的定义，看 20.3.1.16 Date Time String Format 的定义，可以总结出以下几点： 完整的日期时间定义格式为 YYYY-MM-DDTHH:mm:ss.sssZ T 只是作为日期与时间的分隔符，没有实际意义 Z 代表时间为 UTC 时间，当该时间表示为时区时间时，Z 被替换为 +HH:mm 或 -HH:mm 代表对应的时区 有两种类型，一种是 date-only，另一种是 date-time date-only 包括下面三种： YYYY YYYY-MM YYYY-MM-DD date-time 就是上面三种的任意一种后加上下面的一种： THH:mm THH:mm:ss THH:mm:ss.sss 尤其注意到这句话，广为流传的 ECMAScript 5.1 版是没有的： When the time zone offset is absent, date-only forms are interpreted as a UTC time and date-time forms are interpreted as a local time. 也就是说 Z 是可以省略的，省略后的字符串如果属于 date-only 类型时，会被解析成 UTC 时间；如果属于 date-time 类型时，会解析成本地时间。 由此可知，ECMASCript 中定义的 Date Time String Format 是有限的，当给定一个 String 时，我们可以根据这些规则来判断这个 String 是否满足这里的 Date Time String Format。 Date.parse 干了啥实际上，大部分同学都知道 new Date(string) 实际上调用了 Date.parse 方法，20.3.2.2Date ( value )。因此看 20.3.3.2 Date.parse ( string ) 中如此说道： The function first attempts to parse the format of the String according to the rules (including extended years) called out in Date Time String Format (20.3.1.16). If the String does not conform to that format the function may fall back to any implementation-specific heuristics or implementation-specific date formats. 没错 Date.parse 就是先按上文提到的 Date Time String Format 来 format，不满足的话就是 implementation-specific date formats。是的，跟不同浏览器的不同实现有关，也就是未定义行为。 浏览器是爸爸让我们具体来看看不同浏览器对一些典型日期时间串的 format。 new Date('2018-01-01')new Date('2018-1-1')new Date('2018-01-01T08:00:00')new Date('2018-01-01 08:00:00')// ChromeMon Jan 01 2018 08:00:00 GMT+0800 (CST) - UTCMon Jan 01 2018 00:00:00 GMT+0800 (CST) - 本地Mon Jan 01 2018 08:00:00 GMT+0800 (CST) - 本地Mon Jan 01 2018 08:00:00 GMT+0800 (CST) - 本地// FirefoxDate 2018-01-01T00:00:00.000Z - UTCDate 2018-01-01T00:00:00.000Z - UTCDate 2018-01-01T00:00:00.000Z - 本地Date 2018-01-01T00:00:00.000Z - 本地// SafariMon Jan 01 2018 08:00:00 GMT+0800 (CST) - UTCInvalid DateMon Jan 01 2018 16:00:00 GMT+0800 (CST) - UTCInvalid Date Surprice Mother Fxxker！ 这四个例子中，第一个和第三个是满足 ECMAScript 中 Date Time String Format 的，另外两个是一些我们常用的字符串表示日期时间的格式。 首先不令人意外的是，正如前文所讲，对于不符合 Format 的字符串 format 结果，不同浏览器会有不同的实现，比如第四种带空格的格式，Safari 会直接报错。这也是我上一篇文章中，Angular 使用 date 管道导致 IE11 不兼容的原因。 但更令人意外的是，对于第三种满足 Format 的字符串，居然得出了不一样的结果！Unbelievable！按照规范，2018-01-01T08:00:00 是省略了 time-zone 的 date-time 类型，应该按 local time 进行 format，Chrome 与 Firefox 做得很好，而 Safari 却没有遵循规范。 万事小心我们可以看到，即使是大厂浏览器，也没有完全按规范实现，更何况国内众多大大小小的浏览器。因此在处理 Date 的时候，需要保持警觉： 后端传时间给前端，使用字符串时，尽量使用带时区的完整 ISO 8601 日期时间字符串，即 2018-01-01T08:00:00+08:00 或使用 UTC 时间 2018-01-01T00:00:00Z ，否则前端如果使用 new Date(string) 进行转换，后果可能不堪设想 前端传时间给后端，可以使用标准字符串，也可以直接使用毫秒数，重要的是保持一致 正如 jQuery 之所以能够叱咤风云，直接使用 moment 等库处理日期时间也不失为一个不错的选择 有部分意见认为日期时间在后端数据库可以统一用 Long 保存，这个数字实际上是一个 UTC 时间，需要显示时格式化为本地时区，需要更新时通过转为 UTC 时间保存。这也是一种不错的实践，但带来的问题是数据库查询中没法看到实际的时间。在 MySQL 下，TIMESTAMP 类型是一个不错的选择。 参考资料 关于“时间”的一次探索 JavaScript 时间与日期处理实战:你肯定被坑过 如何正确地处理时间 - 廖雪峰的官方网站","tags":[{"name":"ECMAScript","slug":"ECMAScript","permalink":"https://blog.imtouch.info/tags/ECMAScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.imtouch.info/tags/JavaScript/"},{"name":"Date","slug":"Date","permalink":"https://blog.imtouch.info/tags/Date/"}]},{"title":"Angular 变化检测中的细节","date":"2018-02-28T06:04:34.000Z","path":"2018/02/28/details-in-angular-detect-change/","text":"年前在公司举行了一场盛况空前（误）的前端分享会，我在会上大谈特谈了关于 Angular 的变化检测机制，就在即将迎来完美的收官之时，总是会有淘气鬼提出各种奇奇怪怪的问题，让人不胜其烦（大误）。由于当时无言以对、支支吾吾，便只好会后一番仔细研究后，发出文章以正视听。望日后能弓调马服再大谈特谈（逃 文中提及的 Angular 源码均基于 Angular 官方仓库 tag 4.4.6 onPush 也会触发 View 更新？Question淘气鬼的第一个问题是关于 onPush 策略下 View 的更新问题。 首先是一段网上举例再多不过的关于使用 Observable + onPush 来减少组件变化检测的代码： @Component(&#123; selector: 'app', template: ` &lt;button (click)=\"emit()\"&gt;&lt;/button&gt; &lt;sub-a [observable]=\"subject\"&gt;&lt;/sub-a&gt; `&#125;)export class AppComponent &#123; subject = new Subject(); emit() &#123; this.subject.next(Math.random()); &#125;&#125;@Component(&#123; selector: 'sub-a', template: ` &lt;p&gt;&#123;&#123;local&#125;&#125;&lt;/p&gt; `, changeDetection: ChangeDetectionStrategy.OnPush&#125;)export class SubAComponent implements OnInit &#123; local; @Input() observable; constructor(private changeDetector: ChangeDetectorRef) &#123; &#125; ngOnInit() &#123; this.observable.subscribe(value =&gt; &#123; this.local = value; // this.changeDetector.markForCheck(); &#125;); &#125;&#125; 毫无疑问地，了解过 ChangeDetectionStrategy.OnPush 的同学都明白，此时 sub-a 组件的 local 值虽然被改变了，但由于没有调用 markForCheck 方法，且所有 @Input 属性没有发生改变，Angular 会跳过该组件（及其子组件）的所有变化检测，因此页面并不会更新。去掉这个 markForCheck 方法的注释，页面就能够得到更新了。具体可以去查阅其他关于 OnPush 策略的文章。 好了，这时候淘气鬼说，那如果我们不是改变一个 @Input 的变量，而是一个内部变量呢？View 会更新吗？即： @Component(&#123; selector: 'app', template: ` &lt;sub-a&gt;&lt;/sub-a&gt; `&#125;)export class AppComponent &#123;&#125;@Component(&#123; selector: 'sub-a', template: ` &lt;button (click)=\"change()\"&gt;&lt;/button&gt; &lt;p&gt;&#123;&#123;local&#125;&#125;&lt;/p&gt; `, changeDetection: ChangeDetectionStrategy.OnPush&#125;)export class SubAComponent implements OnInit &#123; local; constructor(private changeDetector: ChangeDetectorRef) &#123; &#125; ngOnInit() &#123; &#125; change() &#123; this.local = Math.random(); &#125;&#125; 这里直接把父子组件间的变量传递去掉了，方便理解。我一开始是认为View 不会更新，原因是既然输入属性没有发生改变，那这个 SubA 组件的变化检测就应该被 skip 掉。然而： 他变了。 简直击碎了我的世界观。 更诡异的情况在我阅读众多资料对 OnPush 策略与 Angular 变化检测的理解中，点击按钮后所发生的应该是： click event =&gt; ngZone 捕获，开始一次从根的变化检测 =&gt; 到 OnPush 策略的组件，跳过 =&gt; 页面不会更新 是哪里出了问题呢？抱着疑问在 Google 的帮助下四海为家（误），期间也咨询了不少人，但也得不到满意的答复，直到在官网的 API 上看到这样一个例子： @Component(&#123; selector: 'cmp', changeDetection: ChangeDetectionStrategy.OnPush, template: `Number of ticks: &#123;&#123;numberOfTicks&#125;&#125;`&#125;)class Cmp &#123; numberOfTicks = 0; constructor(private ref: ChangeDetectorRef) &#123; setInterval(() =&gt; &#123; this.numberOfTicks++; // the following is required, otherwise the view will not be updated this.ref.markForCheck(); &#125;, 1000); &#125;&#125;@Component(&#123; selector: 'app', changeDetection: ChangeDetectionStrategy.OnPush, template: ` &lt;cmp&gt;&lt;cmp&gt; `,&#125;)class App &#123;&#125; 这个例子跟淘气鬼的例子很像，区别只在于官网使用了 setInterval 来触发 ViewModel 的更新，而淘气鬼就搞了个按钮。 但是，这个 setInterval 居然是不会更新 View，而点击按钮却是会更新 View，纳尼？这两个对 zone 来说不是都是异步吗？都是触发一轮变化检测吗？ 把淘气鬼的例子改了下，发现的确如此，调用同一个函数 change，每一秒的定时任务 View 不会更新，点击按钮界面就能更新！WHY？如此看来那应该是 ngZone 对这两种异步事件的处理有区别。 @Component(&#123; selector: 'app', template: ` &lt;sub-a&gt;&lt;/sub-a&gt; `&#125;)export class AppComponent &#123;&#125;@Component(&#123; selector: 'sub-a', template: ` &lt;button (click)=\"change()\"&gt;&lt;/button&gt; &lt;p&gt;&#123;&#123;local&#125;&#125;&lt;/p&gt; `, changeDetection: ChangeDetectionStrategy.OnPush&#125;)export class SubAComponent implements OnInit &#123; local; constructor(private changeDetector: ChangeDetectorRef) &#123; &#125; ngOnInit() &#123; setInterval(() =&gt; &#123; this.change(); &#125;, 1000); &#125; change() &#123; this.local = Math.random(); &#125;&#125; 调用绑定事件会自动 markForCheck在 StackOvewflow 上搜索一番，果然还是皇天不负有心人啊 Angular OnPush Component, when trigger event in view angular force markForCheck automatically? 原来原因是，对于 DOM 中绑定的事件，会在内部自动把 markForCheck 帮你调用了。来我们看看源码： // packages/core/src/view/provider.ts - L134export function createDirectiveInstance(view: ViewData, def: NodeDef): any &#123; // Omit... if (def.outputs.length) &#123; for (let i = 0; i &lt; def.outputs.length; i++) &#123; const output = def.outputs[i]; const subscription = instance[output.propName !].subscribe( eventHandlerClosure(view, def.parent !.nodeIndex, output.eventName)); view.disposables ![def.outputIndex + i] = subscription.unsubscribe.bind(subscription); &#125; &#125; return instance;&#125;function eventHandlerClosure(view: ViewData, index: number, eventName: string) &#123; return (event: any) =&gt; &#123; try &#123; return dispatchEvent(view, index, eventName, event); &#125; catch (e) &#123; // Attention: Don't rethrow, as it would cancel Observable subscriptions! view.root.errorHandler.handleError(e); &#125; &#125;;&#125; 这里只需要看到绑定事件的处理函数是 eventHandlerClosure，而这个处理函数则是调用了 dispatchEvent。 // packages/core/src/view/util.ts - L128export function dispatchEvent( view: ViewData, nodeIndex: number, eventName: string, event: any): boolean &#123; const nodeDef = view.def.nodes[nodeIndex]; const startView = nodeDef.flags &amp; NodeFlags.ComponentView ? asElementData(view, nodeIndex).componentView : view; markParentViewsForCheck(startView); return Services.handleEvent(view, nodeIndex, eventName, event);&#125; 而 dispatchEvent 则是调用了 markParentViewsForCheck。没错就是这个通知了 Angular 触发 View 更新，我们来看看 ChangeDetectorRef.markForCheck 的源码。 // packages/core/src/view/refs.ts - L248export class ViewRef_ implements EmbeddedViewRef&lt;any&gt;, InternalViewRef &#123; // Omit... markForCheck(): void &#123; markParentViewsForCheck(this._view); &#125; // Omit...&#125; 没错，markForCheck 的内部就是通过 markParentViewsForCheck 实现的。 总结下来，其实我的理解是没错的，使用了 OnPush 策略，无论如何改变变量，只要没有 markForCheck，View 的确是不会更新的。 OnPush 会更新 View 的情况那篇 StackOverflow 有个介绍 OnPush 策略下什么情况会更新 View 的总结，顺带也搬运一下。 Change Detection issue — Why is this changing when it’s the same object reference with On Push @Input 属性改变这是最通常的理解了。内部通过将 ViewState 置为 ChecksEnabled 使组件重新加入变化检测。 // packages/core/src/view/provider.ts - L424function updateProp( view: ViewData, providerData: ProviderData, def: NodeDef, bindingIdx: number, value: any, changes: SimpleChanges): SimpleChanges &#123; if (def.flags &amp; NodeFlags.Component) &#123; const compView = asElementData(view, def.parent !.nodeIndex).componentView; if (compView.def.flags &amp; ViewFlags.OnPush) &#123; compView.state |= ViewState.ChecksEnabled; &#125; &#125;&#125; 组件内触发绑定事件也就是上文分析的情况。 手动调用 markForCheck这个也没有问题，手动把该组件重新设置为可 Check。 Async pipe这个我也真没想到，async pipe 内部也自动调用了 markForCheck，不过考虑到它连销毁都自带了，这也可以理解。 // packages/common/src/pipes/async_pipe.ts - L139private _updateLatestValue(async: any, value: Object): void &#123; if (async === this._obj) &#123; this._latestValue = value; this._ref.markForCheck(); &#125;&#125; ViewCheck 的执行顺序Question这是淘气鬼的第二个问题，在展示组件生命周期钩子调用顺序的时候，有如下的组件树（丑）结构： 组件树 请问他的 ngAfterViewChecked 钩子的执行顺序是啥呢？ 我一开始以为会是 BDCA，没错就是一个树的后序遍历。但现实却是 DBCA！这是什么鬼！ 到底是谁 Check 谁？这个其实怪我一时没有明白 Change Detection 的步骤，这里强烈推荐我认为全网写得最好的关于 Angular 变化检测的文章： Everything you need to know about change detection in Angular 里面总结了对于每个组件一轮变化检测要执行的步骤，重点关注 10) 和 12) 步： 10) runs change detection for a child view (repeats the steps in this list) 12) call AfterViewInit and AfterViewChecked lifecycle hooks on child component instance (AfterViewInit is called only during first check) 整个步骤看下来，我们发现了这样两件事。 第一，子组件的递归变化检测是在调用 ViewCheck 钩子前进行的。 第二，比如，当组件 A 执行完一轮变化检测后，A.ngAfterViewChecked 并没有被调用。仔细查看每一个步骤，对组件 A 的变化检测中，确实没有调用 A 的 ViewCheck 钩子这样的步骤。那这个钩子是在什么时候调用的呢？ 回到上面提到的 12) 步，对于每个组件的一轮变化检测，需要去调用子组件的 ViewCheck 钩子。因此，比如，A 组件的 ViewCheck 钩子是谁调用的呢？就是 A 组件的父组件调用的，而不是 A 自身，是 A 的父组件去确认 A 已经 Check 了。 理解了这两个以后，上面那个组件树的 ViewCheck 调用顺序就非常清晰了。 详细描述针对上图的组件树，只 focus 递归变化检测和 ViewCheck 下的具体调用情况如下： A Begin Change detection A 组件有两个子组件 B/C B Begin Change detection B 调用所有子组件的 ViewCheck 钩子（无输出） B End Change detection C Begin Change detection C 组件有子组件 D D Begin Change detection D 调用所有子组件的 ViewCheck 钩子（无输出） D End Change detection C 调用所有子组件的 ViewCheck 钩子（输出 D） C End Change detection A 调用所有子组件的 ViewCheck 钩子（输出 B C） A End Change detection 这样下来，DBCA 的输出就非常显而易见了。 无奖问答看看你掌握了吗？下面这个组件树的 ViewCheck 钩子顺序是啥呢？ 搞事的组件树 答案看后文的图片。 ContentCheck值得注意的是，ContentCheck 的顺序跟 ViewCheck 十分类似，也是父组件的变化检测中调用子组件的钩子，只不过这是在递归之前进行的调用。 上文的两个组件树的 ContentCheck 顺序分别为：ABCD 和 ABDCEF，看看能不能明白？ 结果 总结总的来说，淘气鬼的问题基本上都解决了，算是可喜可贺，普天同庆了。Angular 果真是博大精深，看源码都要看晕了，不过也多亏了淘气鬼，让我对 Angular 变化检测的理解又上了一个台阶。另外也可以看出像 Angular 这样的大框架要是没有 TypeScript 来支持，真的是鬼才看得懂它的代码咯。","tags":[{"name":"Angular","slug":"Angular","permalink":"https://blog.imtouch.info/tags/Angular/"},{"name":"变化检测","slug":"变化检测","permalink":"https://blog.imtouch.info/tags/变化检测/"},{"name":"源码","slug":"源码","permalink":"https://blog.imtouch.info/tags/源码/"}]},{"title":"Angular 兼容 IE 过程遇到的问题","date":"2018-02-06T01:54:05.000Z","path":"2018/02/06/angular-ie-support/","text":"由于众所周知的原因，Web 应用还是需要兼容 Windows 下最「著名」的浏览器 Internet Explorer 的，可能现在不需要再兼容到 IE6 这么低的版本，但 IE9/10/11 的兼容可能也够麻烦了。 由于我们使用的 Angular + NG-ZORRO-ANTD，两者的官网都说能支持 IE9+，因此我们愉快地开始了 IE 兼容的踩坑之旅。 开启官方提供的 Polyfills查阅的无数资料第一步准是让你把 angular-cli 生成项目中的 polyfills.ts 中的一切都打开，本着「加载慢不慢先不管，能不能用最重要」的原则，我们当然把全部都打开了。 $ npm install --save classlist.js$ npm install --save web-animations-js$ npm install --save intl 把注释里的全部安装完毕，以为兼容 IE 就是这么 Easy, 打开网页依然是一堆的报错… 逐个击破date 管道解析报错我们后端返回的日期时间类型是一个形如 YYYY-MM-DD HH:mm:ss 的字符串，当使用自带的 date 管道进行格式化时： &#123;&#123;startDate | date: 'YYYY年MM月DD日'&#125;&#125; 报错了，IE11 无法将不标准的日期字符串转换为 Date 对象，因此需要自定义一个日期时间格式化管道。 Solved IE11 报错「不能执行已释放 Script 的代码」在 IE11 下会报这个错，错误定位的代码是这样： var testString = delegate.toString(); // &lt;===== HERE!if ((testString === FUNCTION_WRAPPER || testString == BROWSER_TOOLS)) &#123; nativeDelegate.apply(target, args); return false;&#125; 去搜了一下，马上就找到解决方法了，出错原因可以看里面的解释。 Angular 4 app using IE 11, “Can’t execute code from a freed script” Angular 4 put a global constant available to zone.js 一模一样的情况，在 index.html 加上一行 script 把那个全局变量加上去。 &lt;body&gt; &lt;app-root&gt;&lt;/app-root&gt; &lt;script&gt; window['__Zone_disable_IE_check'] = true; &lt;/script&gt;&lt;/body&gt; Solved Array.prototype.includes polyfills在项目中使用了 Array.prototype.includes 这个 ES7 新特性，需要额外的 polyfills，否则 IE 不支持。到 MDN 找一下就好。 MDN - Array.prototype.includes() 我们新建了一个 src/polyfills.js 并在 polyfills.ts 的最后 import 进去，把自己实现的 polyfill 放到 js 文件里。 Solved IE10 Flexbox 支持 如果要兼容到 IE9，你可以忽略这部分内容了，请禁止你（和团队）使用 Flexbox 吧 :Smile: 在业务中，非常频繁的使用了 Flexbox 布局，CanIUse 上表示 Flexbox 对 IE11 也只是部分支持，IE10 直接标红了。但其实 IE10 能够通过 prefix 来实现。 div &#123; display: -ms-flexbox;&#125; 那当然不可能手动每个 div 加啊，我们需要 PostCSS 的 Autoprefixer，经过一番查找，发现 angular-cli 已经集成了 autoprefixer（╰(°▽°)╯），配置一下浏览器列表就能起效了。 Change target browsers for Autoprefixer Solved IE11 无法获取未定义或 null 引用的属性 “call”这个问题是一个量子态的问题，偶尔会出现，但关掉 IE 再重启又没问题了，真的是来搞笑的。 暂时认为是 livereload 导致的代码片段出错，不处理。 Observe IE9 不支持 FileReader我们实现的图片上传组件，使用了 FileReader 来获得图片的 base64 编码，并通过编码上传的服务器。但在 IE9 下，并不支持 FileReader. 其实我们只需要能够将图片转成 base64 编码就可以了，查了一下可以用 canvas 来转诶，而且 canvas IE9 也支持，可以尝试。 Under development IE10 使用了 [hidden] 隐藏元素在一些自定义的组件中，对一些元素使用了 hidden 属性来进行隐藏，在 IE10 下会无法隐藏。 &lt;span class=\"close\" [hidden]=\"!allowRemove || !showControlBtn[i]\"&gt;&lt;/span&gt; 很可惜，hidden 在 IE10 上并不支持。 改成利用 display: none 来隐藏，问题解决。 &lt;span class=\"close\" [class.close-not-exist]=\"!allowRemove || !showControlBtn[i]\"&gt;&lt;/span&gt; Solved IE9 requestAnimationFrame undefined如果使用了 Angular 的动画 @angular/animation， 在 IE9 下会由于不支持 requestAnimationFrame 而报错。自行加上对应的 Polyfill 即可。 需要注意的是，这个 requestAnimationFrame 的 polyfill 需要在 Angular 自带的 polyfills.ts 之前引入，因为下面的代码会用到这个函数，把 import 语句放在 polyfills.ts 的开头即可。 Solved IE11 下改变 file input value 会重新触发 change 事件这个跟 Angular 关系不大，我们实现的不少图片上传或文件上传组件，做法都是隐藏一个 input 框，当有某些 click 事件时调用 input.click() 调出文件选择器，选择后通过 change 事件处理。 在 change 的处理函数的最后，会有这么一句 this.fileEle.nativeElement.value = ''; 在每次处理完用户选择的文件后，把该 input 框的值清空。这么做的原因是 change 事件只有在文件变化时才被触发，当需要处理两次上传同一个文件的情况时 第一次选择了文件 A，第二次依然选择了文件 A 符合组件预期的行为应该是调用两次 change 回调。这里需要说明的是，change 本身的语义是没有问题的，只有文件变化才调用，但组件层面上的语义应该是每次用户选择了文件都执行一个回调，因此单纯的 change 事件不能满足需求。 因此每次把 value = &#39;&#39; 即可解决这个问题。 但在 IE11 的实现认为，设置 value 相当于改变文件，也需要调用 change 回调（Chrome / Firefox 甚至 IE10 也不会调用），因此 change 回调执行了两次，其中第二次的 e.target.files 为空数组，需要特别的处理。 这里有个知乎上的讨论，对 input file 的特性还需要进一步实践，先记录下来 Solved IE9 下 Int32Array undefined在 IE9 下，启动应用并进入时控制台会报这个错，Int32Array undefined 之类的。找到了这个，加上新的 polyfill 即可。 import 'core-js/es6/typed';","tags":[{"name":"Angular","slug":"Angular","permalink":"https://blog.imtouch.info/tags/Angular/"},{"name":"IE","slug":"IE","permalink":"https://blog.imtouch.info/tags/IE/"},{"name":"浏览器兼容","slug":"浏览器兼容","permalink":"https://blog.imtouch.info/tags/浏览器兼容/"}]},{"title":"Mac 上清除 git osxkeychain 保存的登录名密码","date":"2018-01-09T01:25:32.000Z","path":"2018/01/09/mac-clear-osxkeychain/","text":"昨天在公司的 Mac 上 clone 项目时报错，提示无法找到项目。在确信地址没错的情况下，就应该是权限不足导致的无法找到项目。 但一般使用 HTTP 协议来进行 clone 时，都会提示输入用户名密码，但奇怪的是这次并没有提示，而是直接报错，因此怀疑是 Mac 上有记录了默认的用户名和密码，且该用户在 Gitlab 上没有这个仓库的权限。 $ git clone http://172.16.18.121/erp/mobileApproval.gitCloning into 'mobileApproval'...remote: The project you were looking for could not be found.fatal: repository 'http://172.16.18.121/erp/mobileApproval.git/' not found Git 凭证管理由于平时大多数时候都在使用 SSH 方式连接 Git 仓库，对使用 HTTP 方式的用户名密码管理不是很熟，因此去看了下官方文档，Git - 凭证管理，里面提到了几点： 默认所有都不缓存。 每一次连接都会询问你的用户名和密码。 “store” 模式会将凭证用明文的形式存放在磁盘中，并且永不过期。 这意味着除非你修改了你在 Git 服务器上的密码，否则你永远不需要再次输入你的凭证信息。 这种方式的缺点是你的密码是用明文的方式存放在你的 home 目录下。 如果你使用的是 Mac，Git 还有一种 “osxkeychain” 模式，它会将凭证缓存到你系统用户的钥匙串中。 这种方式将凭证存放在磁盘中，并且永不过期，但是是被加密的，这种加密方式与存放 HTTPS 凭证以及 Safari 的自动填写是相同的。 特别关注永不过期与 Mac 等关键字可以筛选出这几段描述，简单来说就是「可以把你的用户名密码永远存在电脑上」，因此解决这个问题只需要把这个删掉就可以了。 OSXKeychain根据官方说明，是通过这个命令设置缓存的 git config --global credential.helper &lt;mode&gt; 模式可能是 cache 或者是 store，可能还有一些其他数据。当执行完后，其实也就是往 .gitconfig 文件添加内容（也有可能是 .git-credential），经过一番摸索，发现这些文件都没有什么异常，没有找到任何与账号密码相关的信息。 于是觉得很大可能会是文档提到的 osxkeychain 导致的（OS X 有时候就是这么傻）。了解了原因之后就可以去 Google 了，搜一下 git disable credential-helper osxkeychain 这几个关键字很容易找到这篇 disable git credential-osxkeychain 按高票回答做了一遍 # 全部 unset 一遍呗$ git config --local --unset credential.helper$ git config --global --unset credential.helper# 这个要 sudo$ sudo git config --system --unset credential.helper# 这三个命令都没有显示任何东西了$ git config --local credential.helper$ git config --global credential.helper$ git config --system credential.helper 但发现还是不能成功提示输入用户名密码，继续尝试第二顺位的回答 # 还真的依然有 osxkeychain$ git config -lcredential.helper=osxkeychain# 跟回答一毛一样$ git config --show-origin --get credential.helperfile:/Applications/Xcode.app/Contents/Developer/usr/share/git-core/gitconfig osxkeychain 好了，终于发现这个用户名密码是哪里搞出来的了，把那个文件里的 credential 配置删掉即可重新提示输入用户名密码了。","tags":[{"name":"Mac","slug":"Mac","permalink":"https://blog.imtouch.info/tags/Mac/"},{"name":"Git","slug":"Git","permalink":"https://blog.imtouch.info/tags/Git/"}]},{"title":"激坑！Angular 使用 Http 模块和 FormData 上传文件","date":"2018-01-02T01:48:40.000Z","path":"2018/01/02/angular-formdata-upload-bug/","text":"最近遇见一个常见的需求，便是上传 Excel 文件到后端进行解析。这种东西做得多了，对前端来说无非就是上传个文件，解析的逻辑我又不管的，easy job 啦~ 对于现代浏览器来说，通过 FormData 进行文件上传已经是很通用的做法了，再也不需要使用像构造 form 元素这种方法去做浏览器兼容。可以看到 FormData 的兼容性还是可以的。 CanIUse - FormData 由于正在使用 Angular，于是直接用自带的 HTTP 服务上传文件吧 const file = event.target.files[0];const formData = new FormData();formData.append('file', file);this.http.request(url, new RequestOptions(&#123; method: RequestMethod.Post, body: formData, headers: new Headers(&#123; 'Authorization': `Bearer $&#123;token&#125;` 'Content-Type': 'multipart/form-data' &#125;)&#125;)); 一切都很美好，但后端哥哥反手就丢来一个报错： HTTP Status 400 - Required MultipartFile parameter &apos;file&apos; is not present 纳尼！我去看了下 Chrome dev tool，卧槽文件不见了。为了把锅分得清清楚楚明明白白，快使用 Postman！ 请求正确返回 万念俱灰啊！！！！！！ 于是只能不停地 Google，终于找到了这个： Form data is empty when calling http.post() with ContentType header 纳尼！这个 http 模块有 bug！FormData 不能传文件，所以后端拿不到值。 换成最原始的 XMLHttpRequest const xhr = new XMLHttpRequest();xhr.open('POST', url);xhr.setRequestHeader('Authorization', `Bearer $&#123;token&#125;`);xhr.send(body);xhr.onload = () =&gt; &#123; if (xhr.status === 200) &#123; console.log(xhr.response); &#125;&#125;; 就没有问题了，一切正常。 那个 Issue 的状态是 Closed, 目测可能在 5+ 修复了？我这里的环境是 Angular 4.4.4，无论是使用 HttpModule 还是 HttpClientModule 进行 FormData 的文件上传，后端均拿不到值。","tags":[{"name":"Angular","slug":"Angular","permalink":"https://blog.imtouch.info/tags/Angular/"},{"name":"FormData","slug":"FormData","permalink":"https://blog.imtouch.info/tags/FormData/"}]},{"title":"服务器由零配置","date":"2017-12-06T06:55:31.000Z","path":"2017/12/06/server-configurate/","text":"一直都在用 Vultr 的服务器，但是网速真的太特么慢了，100+ 毫秒的 ping，经常连 4G 都访问不了，做做实验还行，有应用部署在上面就完全用不了。所以最后还是选择了国内大哥阿里云（尼玛贵了一倍有多 那么又要重新在上面部署安装各种环境、软件了，这里记录一下，防止以后又要再迁移。 本文使用的服务器为 CentOS 7.4，需要配置的环境包括： MySQL，远程访问 / 中文编码 Nginx，配置 https / http2 / 开启gzip / SPA 支持 / 代理 RESTFul 路由 Node.js Git MySQL查看 CentOS 版本$ cat /etc/redhat-releaseCentOS Linux release 7.4.1708 (Core) 配置 Yum 源$ curl -LO http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm$ sudo yum localinstall mysql57-community-release-el7-11.noarch.rpm# 检查是否安装成功$ sudo yum repolist enabled | grep &quot;mysql.*-community.*&quot;mysql-connectors-community/x86_64 MySQL Connectors Community 42mysql-tools-community/x86_64 MySQL Tools Community 55mysql57-community/x86_64 MySQL 5.7 Community Server 227 安装$ sudo yum install mysql-community-server 启动服务并查看服务状态$ sudo systemctl enable mysqld$ sudo systemctl start mysqld$ sudo systemctl status mysqld 修改 root 密码并设置允许远程访问MySQL 5.7 启动后，在 /var/log/mysqld.log 文件中给 root 生成了一个默认密码。通过下面的方式找到 root 默认密码，然后登录 mysql 进行修改： $ grep &apos;temporary password&apos; /var/log/mysqld.log[Note] A temporary password is generated for root@localhost: **********$ mysql -u root -pEnter password: mysql&gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;&lt;新密码&gt;&apos;;mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;&lt;新密码&gt;&apos;; 这里注意 MySQL 有相应的密码策略，不允许设置一些强度较低的密码，一般来说有大小写字母与数字字母即可通过校验。若要取消限制可参考 配置默认编码为 UTF-8mb4在配置文件中的对应位置，加上以下配置。（默认引擎使用 InnoDB 可以去掉，看实际需求） $ vi /etc/my.cnf[mysqld]character_set_server=utf8mb4collation-server=utf8mb4_unicode_cidefault-storage-engine=INNODB[client]default-character-set=utf8 重启服务 $ sudo systemctl restart mysqld 登录 MySQL 查看设置是否成功。 mysql&gt; SHOW VARIABLES LIKE &apos;character%&apos;;+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8mb4 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8mb4 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.22 sec) 开启端口如果启用了防火墙，需要开启端口。 $ sudo firewall-cmd --zone=public --add-port=3306/tcp --permanent$ sudo firewall-cmd --reload 如果使用阿里云的话，还需要在管理控制台配置安全组，在公网入方向开放 3306 端口，否则外网无法远程连接到 MySQL 上 Nginx之前在 Vultr 上装的 Nginx 不能开 HTTP2，因为 OpenSSL 的版本不对，要源码编译安装用 1.0.2 的 openssl. 但现在 CentOS 7.4 已经用上了最新的 openssl 了，所以直接用 yum 装就可以支持 http2 了！ $ yum install nginx$ nginx 装好之后马上启动，就能访问了，这样安装的默认配置为 Nginx 配置文件：/etc/nginx Nginx Web 根目录：/usr/share/nginx/html 然后有几件事要搞定：HTTPS、gzip、单页路由配置、API 代理 HTTPS/HTTP2这里应该是包括了 HTTP2 的，但是最新版的 nginx 的 https 模块是默认开启了 h2 的，所以只需要开启 https 就可以了。 https 需要证书认证，免费证书非 Let‘s encrypt 最好用了，配合 certbot 工具，拿到一个证书易如反掌。 获取 Certbot 客户端$ wget https://dl.eff.org/certbot-auto$ chmod a+x ./certbot-auto$./certbot-auto --help 验证域名，并配置 nginx 使用证书在 nginx 的配置文件 server 中添加下列配置，为了通过 Let’s Encrypt 的验证 location ^~ /.well-known/acme-challenge/ &#123; default_type &quot;text/plain&quot;; root /usr/share/nginx/html;&#125;location = /.well-known/acme-challenge/ &#123; return 404;&#125; 测试配置文件是否有效，重启 nginx $ nginx -t$ nginx -s reload 生成证书，最后换成需要进行认证的域名 $ ./certbot-auto certonly --webroot -w /usr/share/nginx/html -d imtouch.info 成功后，在 nginx 的配置文件中添加，注意 ssl_certificate/ssl_certificate_key 的路径正确 server &#123; listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; server_name imtouch.info; root /usr/share/nginx/html; ssl_certificate &quot;/etc/letsencrypt/live/imtouch.info/fullchain.pem&quot;; ssl_certificate_key &quot;/etc/letsencrypt/live/imtouch.info/privkey.pem&quot;; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on;&#125; 再次确认配置文件正确，重启 nginx 即可 $ nginx -t$ nginx -s reload 证书与域名是一一对应的，当需要使用二级域名时，需要再按这个流程申请一个新的证书 自动更新证书测试一下更新，这一步没有在真的更新，只是在调用 Certbot 进行测试 $ ./certbot-auto renew --dry-run 看到成功之后就可以配置自动更新了 # 手动更新$ ./certbot-auto renew -v$ ./certbot-auto renew --quiet --no-self-upgrade 开启 gzip在 /etc/nginx/nginx.conf 的 server 域加入以下语句 注意 JavaScript 的资源有可能 content-type 是 application/javascript，漏了这个一直没压缩 js gzip on;gzip_min_length 1k;gzip_buffers 4 16k;gzip_comp_level 5;gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php application/javascript; 单页路由设置当我们部署了单页应用在 nginx 上时（如 Vue、Angular 等），如果应用的前端路由是使用 HTML5 新的 history API 来做路由（就是地址栏看不到 #，不是用的 Hash），当用户刷新页面的时候，会由于直接找到 nginx 对应的 Web 目录而报 404。因此需要设置 nginx 当找不到文件时，定位回 index.html. location /fastfood/ &#123; try_files $uri $uri/ /fastfood/index.html;&#125; try_files 会检查文件是否存在，不存在就跳转至应用所在的 index.html API 代理使用 nginx 可以代理开放在内部端口的 API 后端应用，这样就不用处理跨域的问题，而且安全性更好 location ^~ /fastfood/api/ &#123; rewrite ^/fastfood/api/(.*) /fastfood/api/$1 break; proxy_http_version 1.1; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_pass http://127.0.0.1:8360/; proxy_redirect off;&#125; 将所有 /fastfood/api 的请求代理到后端的 8360 端口。 Node.js按官网说明，直接用 yum 安装即可。 $ curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -$ sudo yum -y install nodejs$ node -v$ npm -v Git直接使用 yum install git 安装即可。 参考资料 CentOS 7 下 Yum 安装 MySQL 5.7 HTTPS 简介及使用官方工具 Certbot 配置 Let’s Encrypt SSL 安全证书详细教程 Installing Node.js via package manager","tags":[{"name":"服务器","slug":"服务器","permalink":"https://blog.imtouch.info/tags/服务器/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.imtouch.info/tags/MySQL/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blog.imtouch.info/tags/Nginx/"}]},{"title":"Ionic 构建生产版本报错 Maximum call stack size","date":"2017-11-18T02:30:03.000Z","path":"2017/11/18/ionic-maximum-call-error/","text":"Ionic 构建失败使用 ionic-app-scripts build 构建一个应用的生产版本时，发现出现了以下的错误： [18:21:18] ionic-app-script task: &quot;build&quot;[18:21:18] Error: ./node_modules/sockjs-client/lib/main.js Module build failed: RangeError: Maximum call stack size exceeded at narrowTypeByInstanceof (/Users/ryancui/kit/zhangting-wx/node_modules/typescript/lib/typescript.js:36003:44) at narrowTypeByBinaryExpression (/Users/ryancui/kit/zhangting-wx/node_modules/typescript/lib/typescript.js:35911:32) at narrowType (/Users/ryancui/kit/zhangting-wx/node_modules/typescript/lib/typescript.js:36124:32) at narrowType (/Users/ryancui/kit/zhangting-wx/node_modules/typescript/lib/typescript.js:36122:32) at narrowType (/Users/ryancui/kit/zhangting-wx/node_modules/typescript/lib/typescript.js:36127:36) at getTypeAtFlowCondition (/Users/ryancui/kit/zhangting-wx/node_modules/typescript/lib/typescript.js:35723:36) at getTypeAtFlowNode (/Users/ryancui/kit/zhangting-wx/node_modules/typescript/lib/typescript.js:35604:32) at getFlowTypeOfReference (/Users/ryancui/kit/zhangting-wx/node_modules/typescript/lib/typescript.js:35560:51) at checkIdentifier (/Users/ryancui/kit/zhangting-wx/node_modules/typescript/lib/typescript.js:36313:28) at checkExpressionWorker (/Users/ryancui/kit/zhangting-wx/node_modules/typescript/lib/typescript.js:41277:28) @ ./node_modules/sockjs-client/lib/entry.js 3:17-34 @ ./src/pages/home/business-consultation/BusinessConsultationService.ts @ ./src/app/app.module.ngfactory.ts @ 定位一下问题，发现是使用了 sockjs-client 的包导致的，注释掉下面一句的代码后，发现编译通过了！ const sock = new SockJS(WEBSOCKET_URL + '/consulting?token=' + this.globalData.token); 另外，直接用 npm run build 打包并不会有什么问题，只有 npm run build --prod 才出现问题。由于使用了 --prod 打出的包体积比 --dev 会小很多，因此这个问题必须解决。 怎么办遇事不决找 Google，一番查找找到了一个一毛一样的问题，可惜三个月了并没有人鸟他。 ionic production build fails when using sockjs-client with “Maximum call stack size exceeded” 实在太惨了，看来这个问题有点复杂啊。 是谁的锅先把锅分出去，涉及到这个 build 的有： Ionic Framework Webpack TypeScript sockjs-client 因此，首先在用 angular-cli 初始的项目里打包一下这个 sockjs，发现并没有问题，加上 build 日志中的 ngc 编译没有报错，报错出现在 webpack started 后，因此 TypeScript 和 sockjs-client 都应该是清白的。 那应该是 ionic-app-scripts 还有它依赖的 webpack 的问题了，去搜下 Issue，发现了这个： [3.0.0] JavaScript heap out of memory 大意是把 ionic-app-scripts 从 2.1.4 升级到 3.1.2 后，使用 --prod 打包会出现 JavaScript 堆溢出。 现在我们遇到的问题是调用栈满了，为什么调用栈会满了呢？一般来说 sockjs-client 这种使用这么广泛的库应该不会是代码的 bug, 联想一下其实跟这个遇到的问题是类似的。 解决Issue 说在 2.1.4 没问题，3.1.2 堆溢出了，但我们在用 2.1.4 啊，特么调用栈溢出了啊。Fine, Let’s try 3.1.2 [11:57:08] ionic-app-scripts 3.1.2[11:57:08] build prod started ...[11:57:08] clean started ...[11:57:08] clean finished in 2 ms[11:57:08] copy started ...[11:57:08] copy finished in 94 ms[11:57:08] deeplinks started ...[11:57:08] deeplinks finished in 21 ms[11:57:08] ngc started ...[11:57:16] ngc finished in 7.87 s[11:57:16] preprocess started ...[11:57:16] preprocess finished in 1 ms[11:57:16] webpack started ...[11:58:08] webpack finished in 52.80 s[11:58:08] uglify started ...[11:58:08] sass started ...[11:58:10] sass finished in 1.06 s[11:58:10] cleancss started ...[11:58:11] cleancss finished in 1.06 s[11:58:29] uglify finished in 20.64 s[11:58:29] postprocess started ...[11:58:29] postprocess finished in 51 ms[11:58:29] lint started ...[11:58:29] build prod finished in 81.53 s[11:58:32] lint finished in 2.48 s 可以了你敢信！ 然而注意到 webpack 打包居然用了近一分钟，会不会这次只是侥幸成功呢？ 多试几次应该是没有问题了。不过，3.1.2 的构建速度比 2.1.4 下降了不少，慢了快一倍。 Compile Type/Version v2.1.4 v3.1.2 JIT ~8s ~15s AOT ~50s ~80s","tags":[{"name":"Ionic","slug":"Ionic","permalink":"https://blog.imtouch.info/tags/Ionic/"},{"name":"Bug","slug":"Bug","permalink":"https://blog.imtouch.info/tags/Bug/"}]},{"title":"小程序 Page 获取登录态，异步满天飞？","date":"2017-11-09T03:08:18.000Z","path":"2017/11/09/wechat-mini-async-hell/","text":"最近在开发微信小程序，在处理登录逻辑和后续业务页面的关系时，遇到了异步太多太乱的问题，本文来做个关于小程序登录态异步的总结。 登录逻辑与登录态根据小程序文档与官方 Demo 的例子，微信登录逻辑在 app.js 的 App.onLaunch 中实现。另外还需要自行与第三方服务器独立进行一套授权机制，这里我使用了 JWT，在换取 openid 的接口中返回。 整个 app.js 的登录逻辑大致如下，进入小程序后检查微信登录态是否过期，过期了重新调起微信登录并换取新的 JWT 作为与第三方服务器通信的凭证；未过期则从 localStorage 中拉取 token 与用户信息。 App(&#123; onLaunch: function () &#123; const that = this; // 检查用户登录态是否过期，过期了重新登录 wx.checkSession(&#123; success: () =&gt; &#123; //session 未过期，并且在本生命周期一直有效 that.globalData.token = wx.getStorageSync('token'); that.globalData.userInfo = wx.getStorageSync('userInfo'); &#125;, fail: () =&gt; &#123; that.initLoginState(); &#125; &#125;); &#125;, globalData: &#123; token: '', userInfo: null &#125;, // 重新登录 initLoginState: function () &#123; const that = this; // 登录 wx.login(&#123; success: res =&gt; &#123; // 调用获取用户信息接口 wx.getUserInfo(&#123; success: fullUserInfo =&gt; &#123; // 发送 res.code 到后台换取 openId, sessionKey, unionId wx.request(&#123; url: `$&#123;host&#125;/api/auth/loginwx`, method: 'POST', data: &#123; code: res.code, userInfo: fullUserInfo &#125;, success: (&#123;data&#125;) =&gt; &#123; wx.setStorageSync('token', data.data.token); wx.setStorageSync('userInfo', data.data.userInfo); that.globalData.token = data.data.token; that.globalData.userInfo = data.data.userInfo; &#125; &#125;); &#125; &#125;); &#125; &#125;); &#125;&#125;); 业务页面获取数据在 Page 中，不可避免地需要调用第三方服务器的接口获取数据，此时需要使用 JWT 进行授权。当进入页面时就需要拉数据时，请求放在了 Page.onLoad 方法中。 const app = getApp();const host = require('../../config').host;Page(&#123; data: &#123; groups: [] &#125;, onLoad: function () &#123; this.listGroups(); &#125;, // 获取订单团信息 listGroups: function () &#123; wx.request(&#123; url: `$&#123;host&#125;/api/group/list`, header: &#123; 'authorization': app.globalData.token &#125;, success: (&#123;data&#125;) =&gt; &#123; this.setData(&#123; groups: data.data &#125;) &#125; &#125;); &#125;&#125;) 测试时却发现有时候页面有数据，有时候页面无数据。进一步查看请求便发现有时 token 有值，有时 token 拿不到值。 全特么是异步仔细想想就能够明白，原因在于 App.globalData.token 的设置是异步，虽然 App.onLaunch 与 Page.onLoad 有明确的时序性（文档上没有说明，通过测试可发现 Page.onLoad 总在 App.onLaunch 后执行），但「设置 token」与「请求业务接口」两个步骤不能保证其时序性，因此会出现偶尔请求失败的情况。 既然无法保证时序，第一个想法就是 EventBus 了，这种很 free 的东西，用起来功能强大但也很危险。 给 App 添加了一个自己实现的简单全局 EventBus ，并在 checkSession.success 和重新登录设置好 token 后都广播一个登陆成功事件。这时候 Page 就变成这样了。 loggingSubs: null,onLoad: function () &#123; if (app.globalData.token) &#123; this.listGroups(); &#125; else &#123; this.loggingSubs = app.eventBus.on('LOGGING-SUCCESS', this.listGroups.bind(this)); &#125;&#125;,onUnload: function () &#123; this.loggingSubs.off();&#125;, 由于不能保证时序性，如果在 onLoad 方法只订阅事件就会出现： 登录成功了，广播登陆成功事件（没有人订阅，消息被丢弃） 执行 Page.onLoad 方法，订阅事件 结果没有调用业务接口，因此需要处理两种情况。 其实 RxJS 提供了 ReplaySubject 这样的 Observable 来使后订阅的观察者也能收到之前的所有通知，自行实现一个 ReplaySubject 就能去掉这种判断，详见实现一个超简单的 ReplaySubject 每个页面都要这样？如果每个业务 Page 都需要在初始化时调用业务接口，都需要写一套这样的逻辑？有没有什么更好的解决办法？ 更甚之，就算是一些事件绑定，理论上也不能保证事件调用时已经完成登录，难道每次调用业务接口都要写一套这样的判断？ 这个问题的出现根本在于登录态的获取、token 的设置是异步的，而这个异步与业务接口调用需要同步（必须先有 token 才能调用），能否把这个过程通过小程序框架固定成同步？如 Page.onLoad 方法的调用必须在 App 的某个钩子之后？ 如果有更好的解决方法，请不吝赐教，谢谢。","tags":[{"name":"小程序","slug":"小程序","permalink":"https://blog.imtouch.info/tags/小程序/"},{"name":"Async","slug":"Async","permalink":"https://blog.imtouch.info/tags/Async/"}]},{"title":"实现一个超简单的 ReplaySubject","date":"2017-11-09T02:55:40.000Z","path":"2017/11/09/implement-a-replay-subject/","text":"需要一个 EventBus在前一篇文章中提到，通过 EventBus 可以使登录逻辑与业务接口同步起来，当然这也是小程序页面间通信的一种方式，因此需要一个 EventBus. 无非就是自己造轮子或者直接用别人的，由于一直在写 Angular，因此第一想法就是能不能把 RxJS 扔进去，那 Observable/ReplaySubject 不就随便用了吗。但其实需要用到的功能没这么多，其实就是一个简单的 publish/subscribe 就完了，于是就决定自己写一个（Google 抄一个）吧。 需要怎样的 EventBus于是找到了微信小程序跨页面通信解决思路，里面有一个简单的实现，抄过来后我发现有几个问题可以改进： 不需要处理 args，需要传什么数据麻烦你自行包成一个 Object，只给你传 payload 谢谢 销毁订阅还要把这个回调函数也传进去也太不科学了，RxJS 不是都是返回一个值，调一下 .unsubscribe() 就可以了吗 无法实现 Replay，必须先订阅再广播，不满足需求啊 那就改一改吧。 总体思路思路非常相似，用一个 stores 把所有事件的回调存起来，暴露 on 用于订阅事件，emit 用于广播。跟原来的设计有变化的有： 新建一个 Subscription 类，用于 on() 的返回值，以后我们可以调用 Subscription.off() 来直接销毁订阅 不再处理更多的广播数据，只处理 payload 使用 cache 来缓存所有 emit 过的值，并在新订阅者到来时重放这些值 Subscription销毁订阅的实质是去 stores 里把对应的事件回调函数删掉就可以了，文章原来的方法之所以要传入回调就是去定位这个函数，后来改成了把 Page Context 传进去了。 为了定位可以简单直接一点啊，用一个自增 id 来定位就好了。因此需要一个 ID 生成器，一个简单闭包： this.getAutoIncrese = (function() &#123; let seq = 1; return function () &#123; ++seq; &#125;;&#125;)(); 定位解决了，下一步就是删掉，只需要拿到这个 stores 变量就 ok 了。那就在 Subscription 里保留一份 EventBus 的实例就好了。 class Subscription &#123; eventBus; eventName; cbId; constructor(eventBus, eventName, cbId) &#123; this.eventBus = eventBus; this.eventName = eventName; this.cbId = cbId; &#125; // 销毁订阅事件 off() &#123; this.eventBus.off(this.eventName, this.cbId); &#125;&#125; 整个 Subscripton 就基本完成了，这里的 off() 是直接调用 EventBus 的方法销毁。在 EventBus 的 on 方法中返回一个 Subscription 示例。 return new Subscription(this, eventName, cbId); 只处理 payload当然能够允许多个参数的确更方便，但有时候约定带来的简化是明显的。 emit(eventName, payload) &#123; const eventArray = this.stores[eventName]; if (eventArray) &#123; eventArray.forEach(e =&gt; &#123; e.fn.apply(null, payload); &#125;); &#125;&#125; 不用关心 arguments 究竟是不是一个数据，调用 Array.from 还是 Array.prototype.slice 好，这些细节会让人抓狂。 加入 Replay重放的逻辑也很简单，emit 的时候存起来，判断一下有没有超长，超长去掉最旧那个；on 的时候把存起来的值在新的回调上重放。 // define cache and cacheMaxconstructor(cacheMax) &#123; this.cache = &#123;&#125;; this.cacheMax = cacheMax || 1;&#125;// on segment: replay the emit value on new fnif (this.cache[eventName]) &#123; this.cache[eventName].forEach(payload =&gt; &#123; fn.apply(null, payload); &#125;);&#125;// emit segment: reserve the emit valueif (!this.cache[eventName]) &#123; this.cache[eventName] = [];&#125;if (this.cache[eventName].length === this.cacheMax) &#123; this.cache[eventName].shift();&#125;this.cache[eventName].push(payload); 这样一个超简单的 ReplaySubject 就搞定了。","tags":[{"name":"Observable","slug":"Observable","permalink":"https://blog.imtouch.info/tags/Observable/"},{"name":"EventBus","slug":"EventBus","permalink":"https://blog.imtouch.info/tags/EventBus/"}]},{"title":"你确定要用 Angular 双向绑定吗？","date":"2017-11-07T03:35:42.000Z","path":"2017/11/07/angular-double-binding-rusure/","text":"源起…在写一个文件上传组件的时候，在上层把文件列表 files: UploadFile[] 传给组件，打算用双向绑定。例如这样： _files: UploadFile[] = [];@Output() filesChange = new EventEmitter();@Input()get files() &#123; return this._files;&#125;set files(v) &#123; this._files = v; this.filesChange.emit(v);&#125; 在写到某个删除文件方法的时候，突然发现，貌似这个 setter 根本没有进去啊 this.files.splice(i, 1); files 本身就是一个数组，引用没变就没有进 setter，那上层的变量不就没变了吗？赶紧去父组件看一看，却发现数组还真的删掉了一个文件。 WHAT THE FUCK??? 智障…这个问题困扰了我二十分钟，期间我不停地 Google Angular double binding object/array，发现没人遇到和我一样的问题啊，网上的例子都是用的 Primitive value, 没人用数组做例子的吗？为什么没进 setter 都能变啊，好难啊！ 最后突然灵光一闪，特么我改的就是同一个数组啊，为什么要 emit 这个 change 呢？mdzz 感悟… 所以一个 Reference value 为什么要双向绑定呢？你会在组件内部 reset 掉这个地址吗？直接用就好了 用 Reference value 传递数据会导致数据既能在子组件内部被改，父组件也能改，到底谁负责任？说好的单向数据流呢？ 但看了一下 NG-ZORRO 的 Table 组件实现，的确它的 data[i].checked 就是两边都能改的 如果用 ChangeDetectionStrategy.OnPush，Reference value 还会导致组件 view 无法被 rerender","tags":[{"name":"Angular","slug":"Angular","permalink":"https://blog.imtouch.info/tags/Angular/"}]},{"title":"再聊箭头函数 Arrow Function","date":"2017-08-30T05:14:40.000Z","path":"2017/08/30/say-sth-about-arrow-function/","text":"昨天面试的时候问了一个关于箭头函数的问题，回来发现好像自己说错了（装逼失败），于是便重新认识一下这个 ES6 用得最多的东西。 这段时间面试了很多人，当问到箭头函数带来的好处时，大部分人都只说到了写得少（？？？），不需要用 that、self 之类的变量，可以直接使用 this。但当细问下去，其实很多人不了解箭头函数的 this 就是是啥回事（或者包括我自己 先说说在此之前我对箭头函数的理解吧：箭头函数里的 this 是「继承」的，本身不存在自己的 this，当调用到 this 时用的其实是上一层作用域的 this。现在看来这个理解还是有一定偏差。 闭包与词法作用域摘录一段犀牛书的代码，就能很好说明闭包和词法作用域的问题了： var scope = 'global scope';function checkscope() &#123; var scope = 'local scope'; function f() &#123; return scope; &#125; return f;&#125;checkscope()(); 这里返回的是 &#39;local scope&#39;，是因为在函数 f 函数体内访问 scope 变量时，会沿着从 f 开始的作用域链往上查找，因此第一个查找到的变量是在 checkscope 作用域内定义的 scope。 注意无论 f 在何时何地调用，返回的 scope 总是 &#39;local scope&#39;，这是由于作用域查找总是从 f 开始，因此 scope 的值通过词法作用域确定了。 Function 的 this在 ES5 中，函数中的 this 是动态变化的，会根据调用方式的不同产生不同的绑定，只有在被调用时才能确定 this 的值： 普通函数调用时，全局对象（浏览器下非严格模式 window） 作为对象方法调用时，为该对象 作为构造函数调用时，为新对象的引用 使用 call、apply 调用，为绑定的值（第一个参数） 用代码说明一下： function f(change) &#123; if (change) &#123; this.a = 300; &#125; console.log(this.a);&#125;var a = 100;var obj = &#123; a: 200&#125;;// 普通调用，输出 100f();// 方法调用，输出 200obj.f = f;obj.f();// 构造函数调用，改变的是新对象的 a，输出 300, 100, 300var newObj = new f(true);console.log(a);console.log(newObj.a); Arrow Function 的 this先看 MDN 的说明：MDN - 箭头函数，其实写得很清楚了。关键在于箭头函数的 this 是词法作用域绑定这个概念。这意味着箭头函数的 this 类似于一个变量，在定义的时候就已经确定了指向的上下文，而非动态获取。看个例子： var a = 100;var obj1 = &#123; a: 200, b: () =&gt; &#123; console.log(this.a); &#125;&#125;;obj1.b();var obj2 = &#123; a: 200, b: function () &#123; var f = () =&gt; &#123; console.log(this.a); &#125; f(); &#125;&#125;;obj2.b();var ff = obj2.b;ff(); 在箭头函数中，this 可以看成是一个变量，而非关键字，箭头函数本身作用域里并没有 this 的定义，当引用 this 时，会沿着作用域链往上查找（跟闭包那个 scope 好像哦）。 因此例子中的 obj1.b() 跟 obj2.b() 输出分别为 100 和 200，由于 obj1.b 在查找 this 时会一直查找到全局作用域，因此 this.a = 100；而 obj2.b 在 function 作用域就找到了 this（注意使用了 function 定义了函数），而这时的 this 为方法调用的对象 obj2，因此 this.a = 200。 进一步说明这种作用域查找规则的是下面两行，输出是 100. 由于此时 obj2.b 的调用是一个普通函数调用，因此 this 的值是全局对象，所以输出的是 window.a 了。 Arrow Function 到底是啥在了解到箭头函数内部的 this 其实是一个词法绑定的变量时，我不禁怀疑这个箭头函数究竟是个啥，甚至于它是不是一个函数，有没有自己的作用域？ 以前很多对箭头函数的简单解释是「JavaScript 函数的语法糖」，根据前文所述的 this 获取值的不同，已经知道箭头函数与普通函数其实有很大的不同，于是尝试一下： var f = () =&gt; &#123;&#125;;// 'function'typeof f;// truef instanceof Function;// truef.__proto__ === Function.prototype;// 根据 MDN，箭头函数没有原型：undefinedf.prototype 各种证据表明这个箭头函数的确是一个「函数」，只是没有原型对象，因此也就无法作为构造函数调用（new f()）。另外 MDN 提到，箭头函数内除了 this，还有其他普通函数中常用的变量如 arguments 也是词法绑定的，这些变量在箭头函数调用时是沿着作用域链向上查找的。 看看规范14.2.16 Runtime Semantics: Evaluation 里面的 Note 提到箭头函数没有对 this 进行 local binding（本地绑定），这些变量的绑定是在 lexically enclosing environment 中进行的，实际上就是包含箭头函数定义的函数执行环境中定义的，这与我们上文的结论一致。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.imtouch.info/tags/JavaScript/"}]},{"title":"博客 Github 仓库 README","date":"1970-01-02T04:00:00.000Z","path":"1970/01/02/README/","text":"大家好，这个仓库保存了我的 Hexo 博客所有博文的源文件，包括里面用到的图片、流程图的 Graffle 源文件等。可以到 https://blog.imtouch.info 访问我的博客。 目前博客的内容基本以技术为主，欢迎留言交流，也可以在这个 Repo 下开 Issue 进行探讨，谢谢。","tags":[]}]